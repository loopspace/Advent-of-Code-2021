% \iffalse meta-comment
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
Advent of Code 2021 --- LaTeX3 code for solving the Advent of Code 2021
E-mail: loopspace@mathforge.org
Released under the MIT Licence
----------------------------------------------------------------

This is code I've written in LaTeX3 for solving the problems of the Advent of Code 2021
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input l3docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
Advent of Code 2021 --- Functions for solving the problems
E-mail: loopspace@mathforge.org
Released under the MIT Licence
----------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2021 by Andrew Stacey <loopspace@mathforge.org>

This work may be distributed and/or modified under the
conditions of the MIT License

This work consists of the files  advent_code.dtx
and the derived files            advent.ins,
                                 advent_code.pdf,
                                 advent.sty,

\endpostamble
\usedir{tex/latex/advent}
\generate{
  \file{advent.sty}{\from{\jobname.dtx}{advent}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/advent}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
\documentclass[full]{l3doc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
%\usepackage{morefloats}
\usepackage{trace}
\usepackage{advent}
%\traceoff
%\usepackage[numbered]{hypdoc}
\definecolor{lstbgcolor}{rgb}{0.9,0.9,0.9} 
 
\usepackage{listings}
\lstloadlanguages{[LaTeX]TeX}
\lstset{
  breakatwhitespace=true,
  breaklines=true,
  language=[LaTeX]TeX,
  basicstyle=\small\ttfamily,
  keepspaces=true,
  columns=fullflexible
}
 
\usepackage{fancyvrb}

\newenvironment{example}
  {\VerbatimEnvironment
   \begin{VerbatimOut}[gobble=2]{example.out}}
  {\end{VerbatimOut}
   \begin{center}
%   \setlength{\parindent}{0pt}
   \fbox{\begin{minipage}{.9\linewidth}
     \lstinputlisting[]{example.out}
   \end{minipage}}
   \fbox{\begin{minipage}{.9\linewidth}
     \centering
     \input{example.out}
   \end{minipage}}
\end{center}
}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{1.00}{2021/12/05}{Created DTX file}
%
% \DoNotIndex{\newcommand,\newenvironment}
%
% \pdfstringdefDisableCommands{%
%  \def\\{}%
%  \def\url#1{<#1>}%
% }
%
% \providecommand*{\url}{\texttt}
% \GetFileInfo{advent.sty}
% \title{Advent of Code 2021: \LaTeX3 Solutions}
% \author{Andrew Stacey \\ \url{loopspace@mathforge.org}}
% \date{\fileversion~from \filedate}
%
%
% \maketitle
%
% 
% \section{Introduction}
%
% \section{Day 01}
%
% \begin{function}{\CountIncreases}
%
% For this, we take advantage of a useful thing with the rolling averages.
% If the first four terms are \(a\), \(b\), \(c\), and \(d\) then the first rolling average is \(a + b + c\) and the second is \(b + c + d\), so when comparing these averages it is enough to compare \(a\) with \(d\).
% So we store \(k\) items in a sequence and then compare the next item with the first term of that sequence.
% By then putting that next item on the end of the sequence and removing the first, so that it always stores the most recent \(k\) terms in the main list, we can iterate over the whole list quite efficiently.
%
% \begin{enumerate}
% \item There are
% \CountIncreases{Day01}
% increases in the depths.
% \item There are
% \CountIncreases[3]{Day01}
% increases in the \(3\)--item rolling averages of the depths.
% \end{enumerate}
% \end{function}
%
% \section{Day 02}
%
% \begin{function}{\NavigateSub}
%
% For the second task, we can reuse the code since the \Verb!Depth! of the first part now becomes the \Verb!Aim! of the second.
% So it is just a matter of adding the extra counter to the main code and then selecting the right outputs for the user level command.
%
% \begin{enumerate}
% \item
% \NavigateSub*{Day02}
% \item
% \NavigateSub{Day02}
% \end{enumerate}
% \end{function}
%
% \section{Day 03}
%
% \begin{function}{\CalculateRatesGE,\CalculateRatesOCO}
%
% I didn't originally see how to directly use my code from the first part in solving the second.
% Eventually, I hit on the idea of iterating through the list of data with a filter and figuring out the frequency of each bit for those which match the filter.
% For the first part, the filter is just ``allow everything'' but for the second then we gradually build up a prefix to match against.
% The \(\mathrm{CO}_2\) count proved slightly tricky due to the condition that once we have only a single match then we return that.
% With the \(\mathrm{O}_2\) count then we can continue looking for the most frequent bit value even when there's only one left.
% But with the \(\mathrm{CO}_2\) count then we need to flip the behaviour when there's only one left.
%
% \begin{enumerate}
% \item
% \CalculateRatesGE{Day03}
% \item
% \CalculateRatesOCO{Day03}
% \end{enumerate}
% \end{function}
%
%
% \section{Day 04}
%
% \begin{function}{\BingoCards}
%
% The idea of the code here is to convert a bingo card into a \texttt{prop} with keys the numbers on the card and values their positions.
% When running through the called numbers, we can use this prop to figure which row and column each number belongs to.
% Then keeping a count of how many in each row and column have been seen means that we can tell when a card is ``won''.
%
% \begin{enumerate}
% \item First bingo card score:
% \BingoCards{Day04}
% \item Last bingo card score:
% \BingoCards*{Day04}
% \end{enumerate}
% \end{function}
%
%
% \section{Day 05}
%
% \begin{function}{\GridVents}
%
% With the grid vents, we just iterate over the lines and keep count.
% As the grid is \(1000 \times 1000\), we use an \texttt{intarray} to keep track of it (technically, a linearised version of it).
%
% \begin{enumerate}
% \item There are
% \GridVents*{Day05} 
% points where horizontal or vertical lines overlap.
% \item There are
% \GridVents{Day05}
% points where horizontal, vertical, or diagonal lines overlap.
% \end{enumerate}
% \end{function}
%
%
% \section{Day 06}
%
% \begin{function}{\LanternFish}
%
% The main issue with the lantern fish is that when calculating for \(256\) days then we overflow the \LaTeX3 integer arithmetic.
% To cope with it, we need to effectively use double integer arithmetic.
% However, we don't get anywhere near the maximum double limit so we implement the overflow at \(100000000\).
% This means that we can do the overflow \emph{after} the arithmetic since it won't actually overflow, and reconstructing the number for display purposes is simple.
%
% \begin{enumerate}
% \item There are
% \LanternFish{80}{Day06}
% after \(80\) days.
% \item There are
% \LanternFish{256}{Day06}
% after \(256\) days.
% \end{enumerate}
% \end{function}
%
% \section{Day 07}
%
% I cheated slightly here.
% The position that minimises the cost in the first version is the median, so we just calculate that and use it to calculate the fuel cost.
% In the second, the fuel cost is calculated using triangular numbers which are almost squares.
% The position that minimises the cost if it were using squared distances would be the mean.
% So I started by calculating the mean and the fuel cost from that.
% Or rather, from the rounded mean.
% That didn't give the right answer so I then tried rounding the mean the other way and that did work.
% So I didn't technically work out which one minimised it in the code.
%
% \begin{function}{\CrabLine}
% \begin{enumerate}
% \item The cheapest fuel cost is
% \CrabLine*{Day07}
% \item The cheapest fuel cost is
% \CrabLine{Day07}
% \end{enumerate}
% \end{function}
%
% \section{Day 08}
%
% \begin{function}{\DigitScramble,\DigitUnScramble}
%
% For the first digit scramble, as the numbers are uniquely identified by the lengths of the segments used then it is simply a matter of counting terms of those lengths.
%
% I'm quite pleased with my solution to the second part.
% Each segment is used a set number of times in the ten digits and that can be used to figure out which number is which.
% In the unscrambled digits, for example, segment \(e\) is used \(4\) times.
% These numbers aren't unique -- segments \(a\) and \(c\) are both used \(8\) times -- but adding the scores for the segments used in a particular digit produces a number that is unique.
% So taking the ten scrambled segment lists we can figure out the number of times each segment appears to get that list of numbers, then add up the scores of each of the digits that we want to determine so that we can identify them.
%
% \begin{enumerate}
% \item There are
% \DigitScramble{Day08}
% \(1\)s, \(4\)s, \(7\)s, and \(8\)s.
% \item The sum of all the unknown numbers is
% \DigitUnScramble{Day08}.
% \end{enumerate}
% \end{function}
%
%
%
% \section{Day 09}
%
% \begin{function}{\SmokeBasin,\BasinSize}
%
% To make the code a bit simpler, I effectively put a border of \(10\)s around the edge of the grid of numbers.
% This meant that I didn't have to check for edges and corners differently to the rest.
%
% I could think of a few algorithms for the second part.
% One of the paradigms I'm finding when programming in \LaTeX3 is that the time cost has to get quite high before I will switch out a simple inefficient algorithm for a more complicated but efficient one.
% So I could solve this in a single pass by keeping track of each partial basin, and as each line is read in then its non-\(9\) cells get added to the partial basins that it overlaps with, possibly leading to some partial basins getting combined.
% But the data structure required to keep track of everything here is slightly complicated.
% In a normal programming language, each partial basin would be a table with its current size and its ``leading edge'' (which itself would likely be a sequence).
% The basins would then be a list of such objects.
% This concept of a list of tables is something that I find a little tricky to work with in \LaTeX3.
% Ideally, one would like to have a notion of ``anonymous variables'' that can then be stored in a list, and which can be passed around without requiring explicit names.
% I have some thoughts on this, but not at a sufficient level to warrant implementing them here unless really, really needed.
%
% So instead, I went for a simpler algorithm that iterates towards a solution.
% Imagine putting a single object on every non-\(9\) cell.
% Then we allow these objects to ``flow'' downhill until they accumulate in a basin.
% So at each step, we go through all the cells in the grid and ask ``is there a lower-level neighbour that this cell should flow into?''.
% If so, we shift the objects from that cell into its neighbour.
% We keep doing this until we get a pass that doesn't change any cells.
% These are the basins, and the count of objects is their size.
%
% \begin{enumerate}
% \item The sum of the risk levels is \SmokeBasin{Day09}.
% \item The product of the sizes of the largest basins is \BasinSize{Day09}.
% \end{enumerate}
% \end{function}
%
% \section{Day 10}
%
% \begin{function}{\SyntaxScore}
%
% Given that \Verb!{! and \Verb!}! are special characters in \TeX, I thought this would be a good example to get to grips with the \texttt{str} data type.
%
% This one should have been quite quick, since \LaTeX3 has quite a good set of string manipulation routines.
% However, overflow in integer arithmetic caused issues again.
% I ended up writing a \texttt{perl} script to check my numbers and discovered that there were issues with how I was putting big numbers back together.
% It would also appear that having leading zeros on the solution fools the checker.
%
% \begin{enumerate}
% \item The syntax score for corrupted lines is \SyntaxScore*{Day10}.
% \item The syntax score for incomplete lines is \SyntaxScore{Day10}.
% \end{enumerate}
% \end{function}
%
%
% \begin{function}{\OctopusFlash}
%
% \section{Day 11}
%
% \begin{enumerate}
% \item There were \OctopusFlash*{Day11} flashes
% \item The first all-flash was after \OctopusFlash{Day11} steps
%
% \end{enumerate}
% \end{function}
%
%
% \StopEventually{}
%
% \section{Implementation}
%
% \iffalse
%<*advent>
% \fi
% \subsection{Initialisation}
%
%    \begin{macrocode}
%<@@=advent>
%    \end{macrocode}
%
% Got fed up of warnings
%    \begin{macrocode}
\hfuzz=1000pt
%    \end{macrocode}
% Load the \LaTeX3 foundation and register us as a \LaTeX3\ package.
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{expl3}
\ProvidesExplPackage {advent} {2021/12/05} {1.00} {Functions for
solving the Advent of Code 2021}
\RequirePackage{xparse}
%    \end{macrocode}
%
% Utilities copied from \href{https://github.com/loopspace/LaTeX3-Utilities}{LaTeX3-Utilities} for adding something in braces to a token list.
% I find I use this quite a lot in my packages.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_tl_put_right_braced:Nn
{
  \tl_put_right:Nn #1 { { #2 } }
}
\cs_generate_variant:Nn
 \@@_tl_put_right_braced:Nn { NV, cV, cv, Nx, cx }

\cs_new_protected:Nn \@@_tl_gput_right_braced:Nn
{
  \tl_gput_right:Nn #1 { { #2 } }
}
\cs_generate_variant:Nn
 \@@_tl_gput_right_braced:Nn { NV, cV, cv, Nx, cx }

\cs_new_protected:Nn \@@_tl_put_left_braced:Nn
{
  \tl_put_left:Nn #1 { { #2 } }
}
\cs_generate_variant:Nn
 \@@_tl_put_left_braced:Nn { NV, cV, cv, Nx, cx }

\cs_new_protected:Nn \@@_tl_gput_left_braced:Nn
{
  \tl_gput_left:Nn #1 { { #2 } }
}
\cs_generate_variant:Nn
 \@@_tl_gput_left_braced:Nn { NV, cV, cv, Nx, cx }
%    \end{macrocode}
%
%
% I had to think a bit about how to get \TeX\ to work the way I wanted.
% I'm really defining \emph{functions} but \TeX\ doesn't really have that concept, even with all the amazing \LaTeX3 stuff.
% The main issue I had was with scoping and return values.
% By default, \TeX\ functions aren't scoped -- they work on the same level as the calling functions.
% To protect the internals from being overwritten, each core function works inside a group.
% But then I have to work to get the answer out of it.
% So each of my core functions finishes by storing its return value in an appropriate \Verb+output+ variable.
% The core functions are then wrapped in a more user friendly interface that will take that output and assign it to a variable.
% This also means that I can deal with local and global versions without duplicating code.
%
%    \begin{macrocode}
\tl_new:N \g_@@_output_tl
\int_new:N \g_@@_output_int
\seq_new:N \g_@@_output_seq
\bool_new:N \g_@@_output_bool
\prop_new:N \g_@@_output_prop
%    \end{macrocode}
%
% To avoid creating vast numbers of variables, we provide ourselves with a few that we reuse frequently.
% For that reason, most of them don't have very exciting names.
%
% These are general purpose variables.
%    \begin{macrocode}
\tl_new:N \l_@@_tmpa_tl
\tl_new:N \l_@@_tmpb_tl
\tl_new:N \l_@@_tmpc_tl
\tl_new:N \l_@@_tmpd_tl
\tl_new:N \l_@@_tmpe_tl
\tl_new:N \l_@@_tmpf_tl
\tl_new:N \l_@@_tmpg_tl
\tl_new:N \l_@@_tmph_tl
\tl_new:N \l_@@_tmpi_tl

\str_new:N \l_@@_tmpa_str
\str_new:N \l_@@_tmpb_str
\str_new:N \l_@@_tmpc_str

\seq_new:N \l_@@_tmpa_seq
\seq_new:N \l_@@_tmpb_seq
\seq_new:N \l_@@_tmpc_seq

\dim_new:N \l_@@_tmpa_dim
\dim_new:N \l_@@_tmpb_dim

\fp_new:N \l_@@_tmpa_fp
\fp_new:N \l_@@_tmpb_fp
\fp_new:N \l_@@_tmpc_fp
\fp_new:N \l_@@_tmpd_fp
\fp_new:N \l_@@_tmpe_fp
\fp_new:N \l_@@_tmpf_fp

\int_new:N \l_@@_tmpa_int
\int_new:N \l_@@_tmpb_int
\int_new:N \l_@@_tmpc_int
\int_new:N \l_@@_tmpd_int

\bool_new:N \l_@@_tmpa_bool
\bool_new:N \l_@@_tmpb_bool

\ior_new:N \l_@@_tmpa_ior
\iow_new:N \l_@@_tmpa_iow

\prop_new:N \l_@@_tmpa_prop

\msg_new:nnn
 { advent }
 { missing file }
 { File~ #1~ doesn't~ exist~ \msg_line_context:}

%    \end{macrocode}
%
% On occasion we run into arithmetic overflow.
% To make life a little easier, we overflow at a power of \(10\).
%    \begin{macrocode}
\int_const:Nn \c_@@_overflow_int {100000000}
\cs_new_protected_nopar:Npn \double_int_to_tl:NNN #1#2#3
{
  \tl_set:Nx #1 {\int_use:N #3}
  \int_compare:nNnT {#2} > {0}
  {
    \prg_replicate:nn {8 - \tl_count:N #1}
    {
      \tl_put_left:Nn #1 {0}
    }
    \tl_put_left:Nx #1 {\int_use:N #2}
  }
}
%    \end{macrocode}
%
%
% We save our answers in a prop that is written to an output file at the end of the document.
%    \begin{macrocode}
\prop_new:N \g_@@_answers_prop

\file_get:nnNT {advent_answers.txt} {} \l_@@_tmpa_tl
{
  \tl_use:N \l_@@_tmpa_tl
}

\prop_gremove:Nn \g_@@_answers_prop {Template}
\prop_gremove:Nn \g_@@_answers_prop {DigitScramble}


\AddToHook {enddocument} 
{
  \iow_open:Nn \l_@@_tmpa_iow {advent_answers.txt}
  \prop_map_inline:Nn \g_@@_answers_prop
  {
    \iow_now:Nn \l_@@_tmpa_iow
    {
      \prop_gput:Nnn \g_@@_answers_prop {#1} {#2}
    }
  }
  \iow_close:N \l_@@_tmpa_iow
}



%    \end{macrocode}
%
% \begin{macro}{
% \CountIncreases
% }
% Take in a file of integers and count the changes.
% The second argument contains the step for the comparisons, so that the \(n\)th term is compared with the \(n+k\)th term.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_count_increases:nn #1#2
{
  \group_begin:
%    \end{macrocode}  
% Try to open the data file
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#1 .txt}
  {
%    \end{macrocode}  
% That was successful, so now initialise the count and a sequence which will hold the first \(k\) terms.
%    \begin{macrocode}
    \int_zero:N \l_@@_tmpa_int
    \seq_clear:N \l_@@_tmpa_seq
%    \end{macrocode}  
% Load in the first \(k\) lines of the file into the sequence.
%    \begin{macrocode}
    \int_step_inline:nnn {1} {#2}
    {
      \ior_get:NN \l_@@_tmpa_ior \l_@@_tmpa_tl
      \seq_put_right:NV \l_@@_tmpa_seq \l_@@_tmpa_tl
    }
%    \end{macrocode}  
% Now step through the rest of the file, comparing each value with the first value in the sequence of saved items (which we pop off the sequence).
%    \begin{macrocode}
    \ior_map_inline:Nn \l_@@_tmpa_ior
    {
%    \end{macrocode}  
% Start by removing the initial element in the sequence
%    \begin{macrocode}
      \seq_pop:NN \l_@@_tmpa_seq \l_@@_tmpb_tl
%    \end{macrocode}
% Compare that with the current item
%    \begin{macrocode}
      \int_compare:nNnT {##1} > {\l_@@_tmpb_tl}
      {
%    \end{macrocode}
% New term is bigger, so increment the counter
%    \begin{macrocode}     
        \int_incr:N \l_@@_tmpa_int
      }
%    \end{macrocode}
% Now store the new term on the end of the sequence.
%    \begin{macrocode}
      \seq_put_right:Nn \l_@@_tmpa_seq {##1}
    }
%    \end{macrocode}
% Save the count of increments in the output register and close the file.
%    \begin{macrocode}
    \int_gset_eq:NN \g_@@_output_int \l_@@_tmpa_int
    \ior_close:N \l_@@_tmpa_ior
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#1}
  }
  \group_end:
}
%    \end{macrocode}
% Wrap the above in a user command.
%    \begin{macrocode}
\NewDocumentCommand \CountIncreases {O{1} m}
{
  \prop_get:NnNTF \g_@@_answers_prop {Increases#1} \l_@@_tmpa_tl
  {
    \int_gset:Nn \g_@@_output_int {\l_@@_tmpa_tl}
  }
  {
    \@@_count_increases:nn {#2}{#1}
    \prop_gput:NnV
    \g_@@_answers_prop {Increases#1} \g_@@_output_int
  }

  \int_use:N \g_@@_output_int
  \int_gzero:N \g_@@_output_int
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
% \NavigateSub
% }
%
%    \begin{macrocode}
\tl_new:N \c_@@_forward_tl
\tl_new:N \c_@@_up_tl
\tl_new:N \c_@@_down_tl
\tl_gset:Nn \c_@@_forward_tl {forward}
\tl_gset:Nn \c_@@_up_tl {up}
\tl_gset:Nn \c_@@_down_tl {down}
\cs_new_protected_nopar:Npn \@@_navigate_sub:n #1
{
  \group_begin:
%    \end{macrocode}  
% Try to open the data file
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#1 .txt}
  {
%    \end{macrocode}  
% That was successful, so initialise the counters and start slurping through the file.
% The counters track:
% \begin{enumerate}
% \item \Verb!\l_@@_tmpa_int! Aim
% \item \Verb!\l_@@_tmpb_int! Horizontal distance
% \item \Verb!\l_@@_tmpc_int! Depth
% \end{enumerate}
%    \begin{macrocode}
    \int_zero:N \l_@@_tmpa_int
    \int_zero:N \l_@@_tmpb_int
    \int_zero:N \l_@@_tmpc_int

    \ior_map_inline:Nn \l_@@_tmpa_ior
    {
%    \end{macrocode}
% Read in a line, and split it into the command and amount.
%    \begin{macrocode}
      \seq_set_split:Nnn \l_@@_tmpa_seq {~} {##1}
      \seq_pop:NN \l_@@_tmpa_seq \l_@@_tmpa_tl
      \seq_pop:NN \l_@@_tmpa_seq \l_@@_tmpb_tl
%    \end{macrocode}
% Check the command and modify the appropriate counter
%    \begin{macrocode}
      \tl_case:Nn \l_@@_tmpa_tl
      {
        \c_@@_up_tl
        {
          \int_sub:Nn \l_@@_tmpa_int {\l_@@_tmpb_tl}
        }
        \c_@@_down_tl
        {
          \int_add:Nn \l_@@_tmpa_int {\l_@@_tmpb_tl}
        }
        \c_@@_forward_tl
        {
          \int_add:Nn \l_@@_tmpb_int {\l_@@_tmpb_tl}
          \int_add:Nn \l_@@_tmpc_int
          {(\l_@@_tmpb_tl) * (\l_@@_tmpa_int)}
        }
      }
    }
%    \end{macrocode}
% Now save the two counters into the output register.
%    \begin{macrocode}    
    \tl_gset:Nx \g_@@_output_tl {
      { \int_use:N \l_@@_tmpa_int }
      { \int_use:N \l_@@_tmpb_int }
      { \int_use:N \l_@@_tmpc_int }
    }
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#1}
  }
  \group_end:
}
%    \end{macrocode}
% Wrap the above in a user command.
%    \begin{macrocode}
\NewDocumentCommand \NavigateSub {s m}
{
  \prop_get:NnNTF \g_@@_answers_prop {NavigateSub} \l_@@_tmpa_tl
  {
    \tl_gset_eq:NN \g_@@_output_tl \l_@@_tmpa_tl
  }
  {
    \@@_navigate_sub:n {#2}
    \prop_gput:NnV \g_@@_answers_prop {NavigateSub} \g_@@_output_tl
  }

  \IfBooleanTF {#1}
  {
    \tl_set:Nn \l_@@_tmpa_tl {1}
  }
  {
    \tl_set:Nn \l_@@_tmpa_tl {3}
  }
  \begin{itemize}
\item Depth:~\tl_item:Nn \g_@@_output_tl {\l_@@_tmpa_tl}
\item Distance:~\tl_item:Nn \g_@@_output_tl {2}
\item Product:~\int_eval:n
  {
    (\tl_item:Nn \g_@@_output_tl {\l_@@_tmpa_tl})
    *
    (\tl_item:Nn \g_@@_output_tl {2})
  }
  \end{itemize}
  \tl_gclear:N \g_@@_output_tl
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{
% \CalculateRatesGE,
% \CalculateRatesOCO
% }
%
%    \begin{macrocode}
\int_const:Nn\c_@@_bitlength_int {12}
\cs_new_protected_nopar:Npn \@@_calculate_rate:nn #1#2
{
  \group_begin:
%    \end{macrocode}  
% Try to open the data file
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#2 .txt}
  {
%    \end{macrocode}
% Initialise the sequence that will track the most common values in each bit location.
%    \begin{macrocode}
    \seq_clear:N \l_@@_tmpa_seq
    \int_step_inline:nnn {1} {\c_@@_bitlength_int}
    {
      \seq_put_right:Nn \l_@@_tmpa_seq {0}
    }
%    \end{macrocode}
% We need to know if we have more than one match on the list
%    \begin{macrocode}
    \int_zero:N \l_@@_tmpa_int
%    \end{macrocode}
% Iterate through the file
%    \begin{macrocode}
    \ior_map_inline:Nn \l_@@_tmpa_ior
    {
%    \end{macrocode}
% We test if the line starts with the filter prefix.
% To force a match only at the start of the token lists, we prepend them both with an \Verb!X!.
%    \begin{macrocode}
      \tl_if_in:nnT {X##1} {X#1}
      {
        \int_incr:N \l_@@_tmpa_int
%    \end{macrocode}
% Iterate through binary number.
% If we get a \(1\) then we increment the count for this digit, if we get a \(0\) then we decrement it.      
% This way, if the final tally is positive then we want a \(1\) and if negative a \(0\).
%    \begin{macrocode}
        \seq_clear:N \l_@@_tmpb_seq
        \int_step_inline:nnn {1} {\c_@@_bitlength_int}
        {
          \seq_put_right:Nx \l_@@_tmpb_seq
          {
            \int_eval:n
            {
              \seq_item:Nn \l_@@_tmpa_seq {####1}
              +
              2*(\tl_item:nn {##1} {####1}) - 1
            }
          }
        }
        \seq_set_eq:NN \l_@@_tmpa_seq \l_@@_tmpb_seq
      }
    }
    \ior_close:N \l_@@_tmpa_ior
    \seq_gset_eq:NN \g_@@_output_seq \l_@@_tmpa_seq
    \bool_gset:Nn \g_@@_output_bool
    {
      \int_compare_p:nNn {\l_@@_tmpa_int} > {1}
    }
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#1}
  }
  \group_end:
}
%    \end{macrocode}
% Wrap the above in user commands.
%
% Calculating the Gamma and Epsilon rates is straight-forward.
%    \begin{macrocode}
\NewDocumentCommand \CalculateRatesGE {m}
{
  \prop_get:NnNTF \g_@@_answers_prop {RatesGE} \l_@@_tmpa_tl
  {
    \int_set:Nn \l_@@_tmpa_int {\l_@@_tmpa_tl}
  }
  {
    \@@_calculate_rate:nn {} {#1}
    \int_zero:N \l_@@_tmpa_int
    \seq_map_inline:Nn \g_@@_output_seq
    {
      \int_set:Nn \l_@@_tmpa_int {2 * \l_@@_tmpa_int}
      \int_compare:nNnT {##1} > {0}
      {
        \int_incr:N \l_@@_tmpa_int
      }
    }
    \prop_gput:NnV \g_@@_answers_prop {RatesGE} \l_@@_tmpa_int
  }
  \begin{itemize}
\item Gamma~rate:~\int_use:N \l_@@_tmpa_int
\item Epsilon~rate:~\int_eval:n {4095 - \l_@@_tmpa_int}
\item Power~consumption:~
  \int_eval:n {\l_@@_tmpa_int * (4095 - \l_@@_tmpa_int)}
  \end{itemize}
  \int_zero:N \l_@@_tmpa_int
  \seq_gclear:N \g_@@_output_seq
}
%    \end{macrocode}
%
% Calculating the Oxygen and Carbon-Dioxide is a little trickier.
%    \begin{macrocode}
\cs_generate_variant:Nn \@@_calculate_rate:nn {Vn}
\NewDocumentCommand \CalculateRatesOCO {m}
{
  \prop_get:NnNTF \g_@@_answers_prop {RatesO} \l_@@_tmpa_tl
  {
    \int_set:Nn \l_@@_tmpa_int {\l_@@_tmpa_tl}
  }
  {
    \tl_clear:N \l_@@_tmpa_tl
    \int_step_inline:nnn {1} {\c_@@_bitlength_int}
    {
      \@@_calculate_rate:Vn \l_@@_tmpa_tl {#1}
      \int_compare:nNnTF {\seq_item:Nn \g_@@_output_seq {##1}} < {0}
      {
        \tl_put_right:Nn \l_@@_tmpa_tl {0}
      }
      {
        \tl_put_right:Nn \l_@@_tmpa_tl {1}
      }
    }
    \int_zero:N \l_@@_tmpa_int
    \tl_map_inline:Nn \l_@@_tmpa_tl
    {
      \int_set:Nn \l_@@_tmpa_int {2 * \l_@@_tmpa_int}
      \int_compare:nNnT {##1} > {0}
      {
        \int_incr:N \l_@@_tmpa_int
      }
    }
    \prop_gput:NnV \g_@@_answers_prop {RatesO} \l_@@_tmpa_int
  }
  \prop_get:NnNTF \g_@@_answers_prop {RatesCO} \l_@@_tmpa_tl
  {
    \int_set:Nn \l_@@_tmpb_int {\l_@@_tmpa_tl}
  }
  {
    \tl_clear:N \l_@@_tmpa_tl
    \int_step_inline:nnn {1} {\c_@@_bitlength_int}
    {
      \@@_calculate_rate:Vn \l_@@_tmpa_tl {#1}
      \bool_if:NTF \g_@@_output_bool
      {
        \int_compare:nNnTF {\seq_item:Nn \g_@@_output_seq {##1}} < {0}
        {
          \tl_put_right:Nn \l_@@_tmpa_tl {1}
        }
        {
          \tl_put_right:Nn \l_@@_tmpa_tl {0}
        }
      }
      {
        \int_compare:nNnTF {\seq_item:Nn \g_@@_output_seq {##1}} < {0}
        {
          \tl_put_right:Nn \l_@@_tmpa_tl {0}
        }
        {
          \tl_put_right:Nn \l_@@_tmpa_tl {1}
        }
      }
    }
    \int_zero:N \l_@@_tmpb_int
    \tl_map_inline:Nn \l_@@_tmpa_tl
    {
      \int_set:Nn \l_@@_tmpb_int {2 * \l_@@_tmpb_int}
      \int_compare:nNnT {##1} > {0}
      {
        \int_incr:N \l_@@_tmpb_int
      }
    }
    \prop_gput:NnV \g_@@_answers_prop {RatesCO} \l_@@_tmpb_int
  }
  \begin{itemize}
\item Oxygen~Rate:~\int_use:N \l_@@_tmpa_int
\item Carbon~Dioxide~Rate:~\int_use:N \l_@@_tmpb_int
\item Life~Support~Rating:
  \int_eval:n {\l_@@_tmpa_int * \l_@@_tmpb_int}
  \end{itemize}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{
% \BingoCards
% }
%
% Convert a card into a prop.
% The keys are the numbers, the values are the coordinates of where that number is on the card. 
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_parse_card:N #1
{
  \group_begin:
  \prop_clear:N \l_@@_tmpa_prop
  \int_zero:N \l_@@_tmpa_int
  \int_set:Nn \l_@@_tmpb_int {5}
  \seq_map_inline:Nn #1
  {
    \prop_put:Nnx \l_@@_tmpa_prop {##1}
    {
      { \int_use:N \l_@@_tmpa_int }
      { \int_use:N \l_@@_tmpb_int }
    }
    \int_incr:N \l_@@_tmpa_int
    \int_compare:nNnT {\l_@@_tmpa_int} = {5}
    {
      \int_zero:N \l_@@_tmpa_int
      \int_incr:N \l_@@_tmpb_int
    }
  }
  \prop_gset_eq:NN \g_@@_output_prop \l_@@_tmpa_prop
  \group_end:
}
%    \end{macrocode}
%
% This checks a card to see if is a winner, and computes the score (well, almost) if it does.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_check_card:NN #1#2
{
  \group_begin:
%    \end{macrocode}
% This prop contains the number of values found on each row and column.
%    \begin{macrocode}
  \prop_clear:N \l_@@_tmpb_prop
  \int_step_inline:nnn {0} {9}
  {
    \prop_put:Nnn \l_@@_tmpb_prop {##1} {0}
  }
%    \end{macrocode}
% Clear a boolean and two integer registers
%    \begin{macrocode}
  \bool_set_false:N \l_@@_tmpa_bool
  \int_zero:N \l_@@_tmpa_int
  \int_zero:N \l_@@_tmpb_int
%    \end{macrocode}
% Iterate over the list of bingo numbers 
%    \begin{macrocode}
  \seq_map_inline:Nn #2
  {
    \int_incr:N \l_@@_tmpb_int
%    \end{macrocode}
% See if the number is on the card
%    \begin{macrocode}
    \prop_get:NnNT #1 {##1} \l_@@_tmpa_tl
    {
%    \end{macrocode}
% If it is, keep track of the sum of the numbers we've seen (to use for calculating the score later).
%    \begin{macrocode}
      \int_add:Nn \l_@@_tmpa_int {##1}
%    \end{macrocode}
% If it's on the card, increment the count for the row and column that it lies on.
%    \begin{macrocode}
      \int_step_inline:nnn {1} {2}
      {
        \tl_set:Nx \l_@@_tmpb_tl {\tl_item:Nn \l_@@_tmpa_tl {####1}}
        \prop_get:NVN \l_@@_tmpb_prop \l_@@_tmpb_tl \l_@@_tmpc_tl
        \tl_set:Nx \l_@@_tmpc_tl {\int_eval:n {\l_@@_tmpc_tl + 1}}
        \prop_put:NVV \l_@@_tmpb_prop \l_@@_tmpb_tl \l_@@_tmpc_tl
%    \end{macrocode}
% Compare the new count to see if that row or column has been filled
%    \begin{macrocode}
        \int_compare:nNnT {\l_@@_tmpc_tl } = {5}
        {
%    \end{macrocode}
% If it has, set the flag and stop iterating over the token list
%    \begin{macrocode}
            \bool_set_true:N \l_@@_tmpa_bool
        }
      }
    }
    \bool_if:NT \l_@@_tmpa_bool
    {
      \seq_map_break:
    }
  }
  \bool_gset_eq:NN \g_@@_output_bool \l_@@_tmpa_bool
  \tl_gset:Nx \g_@@_output_tl
  {
    {\int_use:N \l_@@_tmpb_int}
    {\int_use:N \l_@@_tmpa_int}
  }
  \group_end:
}
%    \end{macrocode}
%
% Reads a card into a sequence, collapsing five lines of input into a single sequence.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_read_card:N #1
{
  \group_begin:
  \seq_clear:N \l_@@_tmpa_seq
  
  \int_step_inline:nnn {1} {5}
  {
    \ior_get:NN #1 \l_@@_tmpb_tl
    \seq_set_split:NnV \l_@@_tmpb_seq {~} \l_@@_tmpb_tl
    \seq_concat:NNN \l_@@_tmpa_seq \l_@@_tmpa_seq \l_@@_tmpb_seq
  }
  \seq_remove_all:Nn \l_@@_tmpa_seq {}
  \seq_gset_eq:NN \g_@@_output_seq \l_@@_tmpa_seq
  \group_end:
}
%    \end{macrocode}
%
% Processes the cards
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_process_cards:Nn #1#2
{
  \group_begin:
  \tl_clear:N \l_@@_tmpc_tl
  \seq_clear:N \l_@@_tmpc_seq
%    \end{macrocode}  
% Try to open the data file
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#2 .txt}
  {
%    \end{macrocode}
% Read in the list of numbers and split into a sequence
%    \begin{macrocode}
    \ior_get:NN \l_@@_tmpa_ior \l_@@_tmpa_tl
    \seq_set_split:NnV \l_@@_tmpa_seq {,} \l_@@_tmpa_tl
%    \end{macrocode}
% Initialise the count that will keep track of how long our current ``best'' bingo card took to win.
% If we're looking for the actual best then we initialise the count with the length of the sequence of numbers, if the worst then with \(0\).
%    \begin{macrocode}    
    \token_if_eq_charcode:NNTF #1 <
    {
      \tl_set:Nx \l_@@_tmpc_tl {{\seq_count:N \l_@@_tmpa_seq}}
    }
    {
      \tl_set:Nx \l_@@_tmpc_tl {{0}}
    }
%    \end{macrocode}
% Iterate over the rest of the file
%    \begin{macrocode}
    \bool_do_until:nn
    {
      \ior_if_eof_p:N \l_@@_tmpa_ior
    }
    {
%    \end{macrocode}
% Throw away the blank line
%    \begin{macrocode}
      \ior_get:NN \l_@@_tmpa_ior \l_@@_tmpb_tl
%    \end{macrocode}
% Read in the next five to a sequence
%    \begin{macrocode}
      \@@_read_card:N \l_@@_tmpa_ior
%    \end{macrocode}
% Save that sequence
%    \begin{macrocode}
      \seq_set_eq:NN \l_@@_tmpb_seq \g_@@_output_seq
      \seq_gclear:N \g_@@_output_seq
%    \end{macrocode}
% Convert the card to a prop
%    \begin{macrocode}
      \@@_parse_card:N \l_@@_tmpb_seq
%    \end{macrocode}
% Save that prop
%    \begin{macrocode}
      \prop_set_eq:NN \l_@@_tmpa_prop \g_@@_output_prop
%    \end{macrocode}
% Check the card, stored as a prop, against the bingo numbers
%    \begin{macrocode}
      \@@_check_card:NN \l_@@_tmpa_prop \l_@@_tmpa_seq
%    \end{macrocode}
% If the card ``wins'', see when it won and if it is the current ``best'' then save it.
% We were passed in the comparison operator so that we can decide at call time whether ``best'' is soonest or latest to win.
%    \begin{macrocode}
      \bool_if:NT \g_@@_output_bool
      {
        \int_compare:nNnT {\tl_item:Nn \g_@@_output_tl {1}} #1 {\tl_item:Nn \l_@@_tmpc_tl {1}}
        {
          \tl_set_eq:NN \l_@@_tmpc_tl \g_@@_output_tl
          \seq_set_eq:NN \l_@@_tmpc_seq \l_@@_tmpb_seq
        }
      }
    }
%    \end{macrocode}
% Having gone through them all, we take the winning card and work out its score.
% We know the sum of the numbers that were crossed off, so we negate that and then add the sum of all the numbers on the card.
%    \begin{macrocode}
    \int_set:Nn \l_@@_tmpa_int {0-(\tl_item:Nn \l_@@_tmpc_tl {2})}
    \seq_map_inline:Nn \l_@@_tmpc_seq
    {
      \int_add:Nn \l_@@_tmpa_int {##1}
    }
    \int_set:Nn \l_@@_tmpa_int {\l_@@_tmpa_int * \seq_item:Nn \l_@@_tmpa_seq {\tl_item:Nn \l_@@_tmpc_tl {1}}}
    \int_gset_eq:NN \g_@@_output_int \l_@@_tmpa_int
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#1}
  }
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\NewDocumentCommand \BingoCards {s m}
{
  \IfBooleanTF {#1}
  {
    \prop_get:NnNTF \g_@@_answers_prop {BingoCardsA} \l_@@_tmpa_tl
    {
      \int_gset:Nn \g_@@_output_int {\l_@@_tmpa_tl}
    }
    {
      \@@_process_cards:Nn > {#2}
      \prop_gput:NnV \g_@@_answers_prop {BingoCardsA} \g_@@_output_int
    }
  }
  {
    \prop_get:NnNTF \g_@@_answers_prop {BingoCardsB} \l_@@_tmpa_tl
    {
      \int_gset:Nn \g_@@_output_int {\l_@@_tmpa_tl}
    }
    {
      \@@_process_cards:Nn < {#2}
      \prop_gput:NnV \g_@@_answers_prop {BingoCardsB} \g_@@_output_int
    }
    \@@_process_cards:Nn < {#2}
  }
  \int_use:N \g_@@_output_int
  \int_gzero:N \g_@@_output_int
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{
% \GridVents
% }
% The grid of vent coordinates will be flattened into a one dimensional integer array.
% For this, I'm using the \Verb!intarray! data type.
%
% We know its size.
%    \begin{macrocode}
\intarray_new:Nn \g_@@_grid_intarray {1000*1000}
%    \end{macrocode}
% The second argument is the file name, the first effectively decides whether to count diagonal lines.
% Pass in \(0\) to ignore diagonals, \(1\) to include them.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_grid_lines:nn #1#2
{
  \group_begin:
%    \end{macrocode}
% Initialise the array
%    \begin{macrocode}
  \intarray_gzero:N \g_@@_grid_intarray
%    \end{macrocode}
% Open the file.
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#2 .txt}
  {
%    \end{macrocode}
% Iterate over the list of coordinates
%    \begin{macrocode}
    \bool_do_until:nn
    {
      \ior_if_eof_p:N \l_@@_tmpa_ior
    }
    {
      \ior_get:NN \l_@@_tmpa_ior \l_@@_tmpa_tl
%    \end{macrocode}
% Check it is a valid line (last line might be blank).
%    \begin{macrocode}
      \tl_if_in:NnT \l_@@_tmpa_tl {->}
      {
%    \end{macrocode}
% Parse the input line into coordinates (stored in \Verb!b!, \Verb!c!, \Verb!d!, and \Verb!e! token lists).
%    \begin{macrocode}
        \exp_last_unbraced:NV \@@_grid_parse:w \l_@@_tmpa_tl \q_stop
%    \end{macrocode}
% This checks to see if the line is horizontal, vertical, or diagonal -- just in case there's a dodgy set of coordinates in there.
%    \begin{macrocode}
        \bool_if:nT
        {
          \int_compare_p:nNn {\l_@@_tmpb_tl} = {\l_@@_tmpd_tl}
          ||
          \int_compare_p:nNn {\l_@@_tmpc_tl} = {\l_@@_tmpe_tl}
          ||
          \int_compare_p:nNn {\int_abs:n {\l_@@_tmpb_tl - \l_@@_tmpd_tl}} = {\int_abs:n {\l_@@_tmpc_tl - \l_@@_tmpe_tl}}
        }
        {
%    \end{macrocode}
% Set two integer registers to the linearised position of the start and end coordinates of the line.
% Note that integer arrays are \(1\)--based.
%    \begin{macrocode}
          \int_set:Nn \l_@@_tmpa_int { \l_@@_tmpb_tl + 1000 * (\l_@@_tmpc_tl - 1) }
          \int_set:Nn \l_@@_tmpb_int { \l_@@_tmpd_tl + 1000 * (\l_@@_tmpe_tl - 1) }
%    \end{macrocode}
% The amount to add as we step through the line will be \(1\) if the line is horizontal or vertical, and equal to the first parameter passed to the function if the line is vertical, so we set it to \(1\) initially.
%    \begin{macrocode}
          \int_set:Nn \l_@@_tmpd_int {1}
%    \end{macrocode}
% The step value is a little more complicated.
%    \begin{macrocode}
          \int_zero:N \l_@@_tmpc_int
%    \end{macrocode}
% Check the \(x\)--coordinates.
% If \(x\)--coordinates differ then we need to include a step by \(1\) or \(-1\), depending on which is bigger.
%    \begin{macrocode}
          \int_compare:nNnT {\l_@@_tmpb_tl } < {\l_@@_tmpd_tl}
          {
            \int_add:Nn \l_@@_tmpc_int {1}
          }
          \int_compare:nNnT {\l_@@_tmpb_tl } > {\l_@@_tmpd_tl}
          {
            \int_add:Nn \l_@@_tmpc_int {-1}
          }
%    \end{macrocode}
% Check the \(y\)--coordinates.
% If \(y\)--coordinates differ then we need to include a step by \(1000\) or \(-1000\), depending on which is bigger.
%    \begin{macrocode}
          \int_compare:nNnT {\l_@@_tmpc_tl } < {\l_@@_tmpe_tl}
          {
            \int_add:Nn \l_@@_tmpc_int {1000}
          }
          \int_compare:nNnT {\l_@@_tmpc_tl } > {\l_@@_tmpe_tl}
          {
            \int_add:Nn \l_@@_tmpc_int {-1000}
          }
%    \end{macrocode}
% If both coordinates differ then we're on a diagonal and so we need to set the amount to record for this line to the first parameter.
%    \begin{macrocode}
          \bool_if:nF
          {
            \int_compare_p:nNn {\l_@@_tmpb_tl } = {\l_@@_tmpd_tl}
            ||
            \int_compare_p:nNn {\l_@@_tmpc_tl } = {\l_@@_tmpe_tl}
          }
          {
            \int_set:Nn \l_@@_tmpd_int {#1}
          }
%    \end{macrocode}
% Now we step along the line, incrementing the count at each position as we do.
%    \begin{macrocode}
          \int_step_inline:nnnn {\l_@@_tmpa_int} {\l_@@_tmpc_int} {\l_@@_tmpb_int}
          {
            \intarray_gset:Nnn \g_@@_grid_intarray {##1}
            {
              \intarray_item:Nn \g_@@_grid_intarray {##1} + \l_@@_tmpd_int
            }
          }
        }
      }
    }
%    \end{macrocode}
% Having gone through all the lines, now we count how many positions are unsafe.
%    \begin{macrocode}
    \int_zero:N \l_@@_tmpa_int
    \int_step_inline:nn {1000*1000}
    {
      \int_compare:nNnT {\intarray_item:Nn \g_@@_grid_intarray {##1} } > {1}
      {
        \int_incr:N \l_@@_tmpa_int
      }
    }
%    \end{macrocode}
% Close the file and save the output.
%    \begin{macrocode}
    \ior_close:N \l_@@_tmpa_ior
    \int_gset_eq:NN \g_@@_output_int \l_@@_tmpa_int
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#1}
  }
  \group_end:
}
%    \end{macrocode}
% This function parses an input line and saves the coordinates.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_grid_parse:w #1,#2->#3,#4\q_stop
{
  \tl_set:Nn \l_@@_tmpb_tl {#1}
  \tl_set:Nn \l_@@_tmpc_tl {#2}
  \tl_set:Nn \l_@@_tmpd_tl {#3}
  \tl_set:Nn \l_@@_tmpe_tl {#4}
}
%    \end{macrocode}
% This is our user-defined function.
%    \begin{macrocode}
\NewDocumentCommand \GridVents { s m }
{
  \IfBooleanTF {#1}
  {
    \prop_get:NnNTF \g_@@_answers_prop {GridVentsA} \l_@@_tmpa_tl
    {
      \int_gset:Nn \g_@@_output_int {\l_@@_tmpa_tl}
    }
    {
      \@@_grid_lines:nn {0} {#2}
      \prop_gput:NnV \g_@@_answers_prop {GridVentsA} \g_@@_output_int
    }
  }
  {
    \prop_get:NnNTF \g_@@_answers_prop {GridVentsB} \l_@@_tmpa_tl
    {
      \int_gset:Nn \g_@@_output_int {\l_@@_tmpa_tl}
    }
    {
      \@@_grid_lines:nn {1} {#2}
      \prop_gput:NnV \g_@@_answers_prop {GridVentsB} \g_@@_output_int
    }
  }
  \int_use:N \g_@@_output_int
  \int_gzero:N \g_@@_output_int
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{
% \LanternFish
% }
%
% We save the state as a sequence of integers (no need for an \Verb!intarray! here as the sequence is short).
% The sequence consists of the number of lantern fish in a particular state, except that we're off-by-one since the states start at \(0\) and sequences start at \(1\).
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_lantern_fish:nn #1#2
{
  \group_begin:
%    \end{macrocode}
% Clear the sequence that will hold the states.
% There are no fish initially in state \(0\) (actually, there's a tacit assumption in this code that there's no gaps in the states in the observed fish).
%    \begin{macrocode}
  \seq_clear:N \l_@@_tmpa_seq
  \seq_put_right:Nn \l_@@_tmpa_seq {0}
  \seq_clear:N \l_@@_tmpb_seq
  \seq_put_right:Nn \l_@@_tmpb_seq {0}
%    \end{macrocode}
% Open the file.
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#2 .txt}
  {
%    \end{macrocode}
% Read in the initial list of states of fish and split into a sequence.
% To count how many there are of each state we start by sorting the sequence and then we can count how many there are of each type.
%    \begin{macrocode}
    \ior_get:NN \l_@@_tmpa_ior \l_@@_tmpa_tl
    \ior_close:N \l_@@_tmpa_ior
    \tl_trim_spaces:N \l_@@_tmpa_tl
    \seq_set_from_clist:NN \l_@@_tmpc_seq  \l_@@_tmpa_tl
    \seq_sort:Nn \l_@@_tmpc_seq
    {
      \int_compare:nNnTF { ##1 } > { ##2 }
      { \sort_return_swapped: }
      { \sort_return_same: }
    }
%    \end{macrocode}
% We count each state by stepping through the sequence looking for when it changes.
% When it does, we record the current count and restart a new count.
%    \begin{macrocode}
    \int_set:Nn \l_@@_tmpa_int {1}
    \seq_pop_left:NN \l_@@_tmpc_seq \l_@@_tmpa_tl
    \seq_map_inline:Nn \l_@@_tmpc_seq
    {
      \tl_if_eq:NnTF \l_@@_tmpa_tl {##1}
      {
        \int_incr:N \l_@@_tmpa_int
      }
      {
        \seq_put_right:NV \l_@@_tmpa_seq \l_@@_tmpa_int
        \int_set:Nn \l_@@_tmpa_int {1}
        \tl_set:Nn \l_@@_tmpa_tl {##1}
      }
    }
    \seq_put_right:NV \l_@@_tmpa_seq \l_@@_tmpa_int
%    \end{macrocode}
% Make sure we have a sequence of the right length by padding with \(0\)s. 
%    \begin{macrocode}
    \int_compare:nNnT {\seq_count:N \l_@@_tmpa_seq} < {9}
    {
      \prg_replicate:nn {9 - \seq_count:N \l_@@_tmpa_seq}
      {
        \seq_put_right:Nn \l_@@_tmpa_seq {0}
      }
    }
    \int_compare:nNnT {\seq_count:N \l_@@_tmpb_seq} < {9}
    {
      \prg_replicate:nn {9 - \seq_count:N \l_@@_tmpb_seq}
      {
        \seq_put_right:Nn \l_@@_tmpb_seq {0}
      }
    }
%    \end{macrocode}
% Now we iterate the days.
% Each day, we remove the first term in the sequence (which is the number of fish currently in state \(0\)) which has the effect of decreasing the state of each fish.
% Then the number of fish in state \(0\) is added to the set in state \(6\) and in state \(8\).
% While doing so, we need to save the number of fish in state \(7\) temporarily.
%
% The \(256\) version of this runs into arithmetic overflow, so we have a second sequence for overflow.
% We don't need to be too efficient, so to make life easier at the end we overflow at a power of \(10\).
% \LaTeX3 integers are capped at \(2^{31} - 1\), so we overflow at \(10^9\).
%    \begin{macrocode}
    \prg_replicate:nn {#1}
    {
      \tl_set:Nn \l_@@_tmpd_tl {0}

      \seq_pop_left:NN \l_@@_tmpa_seq \l_@@_tmpa_tl
      \seq_pop_right:NN \l_@@_tmpa_seq \l_@@_tmpb_tl
      \seq_pop_right:NN \l_@@_tmpa_seq \l_@@_tmpc_tl
%    \end{macrocode}
% Test for overflow, if the sum is bigger than the overflow then we subtract our overflow boundary before storing it and set the overflow counter to increment the second sequence.
%    \begin{macrocode}
      \int_compare:nNnTF {\l_@@_tmpa_tl + \l_@@_tmpc_tl} > {\c_@@_overflow_int - 1}
      {
        \seq_put_right:Nx \l_@@_tmpa_seq {\int_eval:n {\l_@@_tmpa_tl + \l_@@_tmpc_tl - \c_@@_overflow_int }}
        \tl_set:Nn \l_@@_tmpd_tl {1}
      }
      {
        \seq_put_right:Nx \l_@@_tmpa_seq {\int_eval:n {\l_@@_tmpa_tl + \l_@@_tmpc_tl }}
      }
      
      \seq_put_right:NV \l_@@_tmpa_seq \l_@@_tmpb_tl
      \seq_put_right:NV \l_@@_tmpa_seq \l_@@_tmpa_tl
      
%    \end{macrocode}
% Second sequence for the overflow
%    \begin{macrocode} 
      \seq_pop_left:NN \l_@@_tmpb_seq \l_@@_tmpa_tl
      \seq_pop_right:NN \l_@@_tmpb_seq \l_@@_tmpb_tl
      \seq_pop_right:NN \l_@@_tmpb_seq \l_@@_tmpc_tl
      \seq_put_right:Nx \l_@@_tmpb_seq {\int_eval:n {\l_@@_tmpa_tl + \l_@@_tmpc_tl + \l_@@_tmpd_tl }}
      \seq_put_right:NV \l_@@_tmpb_seq \l_@@_tmpb_tl
      \seq_put_right:NV \l_@@_tmpb_seq \l_@@_tmpa_tl
    }
%    \end{macrocode}
% Count up the number of fish.
%    \begin{macrocode}
    \int_zero:N \l_@@_tmpa_int
    \int_zero:N \l_@@_tmpb_int
    \seq_map_inline:Nn \l_@@_tmpb_seq
    {
      \int_add:Nn \l_@@_tmpb_int {##1}
    }
    \seq_map_inline:Nn \l_@@_tmpa_seq
    {
      \int_add:Nn \l_@@_tmpa_int {##1}
      \int_compare:nNnT {\l_@@_tmpa_int} > {\c_@@_overflow_int - 1}
      {
        \int_sub:Nn \l_@@_tmpa_int {\c_@@_overflow_int}
        \int_incr:N \l_@@_tmpb_int
      }
    }
    \tl_gclear:N \g_@@_output_tl
    \int_compare:nNnT {\l_@@_tmpb_int} > {0}
    {
      \tl_gset:Nx \g_@@_output_tl {\int_use:N \l_@@_tmpb_int}
    }
    \tl_gput_right:Nx \g_@@_output_tl {\int_use:N \l_@@_tmpa_int}
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#1}
  }
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\NewDocumentCommand \LanternFish {m m}
{
  \prop_get:NnNTF \g_@@_answers_prop {LanternFish#1} \l_@@_tmpa_tl
  {
    \tl_gset_eq:NN \g_@@_output_tl \l_@@_tmpa_tl
  }
  {
    \@@_lantern_fish:nn {#1} {#2}
    \prop_gput:NnV \g_@@_answers_prop {LanternFish#1} \g_@@_output_tl
  }
  \tl_use:N \g_@@_output_tl
  \tl_gclear:N \g_@@_output_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
% \CrabLine
% }
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_crab_line:nn #1#2
{
  \group_begin:
  \seq_clear:N \l_@@_tmpa_seq
%    \end{macrocode}
% Open the file and read in the data to a sequence.
% Sort the sequence for simplicity.
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#2 .txt}
  {
    \ior_get:NN \l_@@_tmpa_ior \l_@@_tmpa_tl
    \ior_close:N \l_@@_tmpa_ior
    \tl_trim_spaces:N \l_@@_tmpa_tl
    \seq_set_from_clist:NN \l_@@_tmpa_seq  \l_@@_tmpa_tl
    \seq_sort:Nn \l_@@_tmpa_seq
    {
      \int_compare:nNnTF { ##1 } > { ##2 }
      { \sort_return_swapped: }
      { \sort_return_same: }
    }
%    \end{macrocode}
% The line that minimises the amount of fuel in the first version is the median.
%    \begin{macrocode}
    \tl_if_empty:nTF {#1}
    {
      \int_set:Nn \l_@@_tmpa_int { (\seq_count:N \l_@@_tmpa_seq) / 2 + 1}
      \int_set:Nn \l_@@_tmpb_int {\seq_item:Nn \l_@@_tmpa_seq { \l_@@_tmpa_int }}

      \int_zero:N \l_@@_tmpa_int
      \seq_map_inline:Nn \l_@@_tmpa_seq
      {
        \int_compare:nNnTF {##1} < {\l_@@_tmpb_int}
        {
          \int_add:Nn \l_@@_tmpa_int {\l_@@_tmpb_int - ##1}
        }
        {
          \int_add:Nn \l_@@_tmpa_int {##1 - \l_@@_tmpb_int}
        }
        
      }

    }
%    \end{macrocode}
% In the second, it is the mean
%    \begin{macrocode}
    {
      \int_zero:N \l_@@_tmpa_int
      \int_zero:N \l_@@_tmpb_int
      \seq_map_inline:Nn \l_@@_tmpa_seq
      {
        \int_add:Nn \l_@@_tmpa_int {##1}
      }
      \fp_set:Nn \l_@@_tmpa_fp {\l_@@_tmpa_int / \seq_count:N \l_@@_tmpa_seq}
      \int_set:Nn \l_@@_tmpb_int {\fp_eval:n {round(\l_@@_tmpa_fp)}}

      \int_zero:N \l_@@_tmpa_int
      \seq_map_inline:Nn \l_@@_tmpa_seq
      {
        \int_compare:nNnTF {##1} < {\l_@@_tmpb_int}
        {
          \int_add:Nn \l_@@_tmpa_int {((\l_@@_tmpb_int - ##1) * (\l_@@_tmpb_int - ##1 + 1))/2 }
        }
        {
          \int_add:Nn \l_@@_tmpa_int {((##1 - \l_@@_tmpb_int) * (##1 - \l_@@_tmpb_int + 1))/2 }
        }
      }

    }
    \int_gset_eq:NN \g_@@_output_int \l_@@_tmpa_int
    
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#2}
  }
  \group_end:
}

\NewDocumentCommand \CrabLine {s m}
{
  \IfBooleanTF {#1}
  {
    \prop_get:NnNTF \g_@@_answers_prop {CrabLineA} \l_@@_tmpa_tl
    {
      \int_gset:Nn \g_@@_output_int {\l_@@_tmpa_tl}
    }
    {
      \@@_crab_line:nn {} {#2}
      \prop_gput:NnV \g_@@_answers_prop {CrabLineA} \g_@@_output_int
    }
  }
  {
    \prop_get:NnNTF \g_@@_answers_prop {CrabLineB} \l_@@_tmpa_tl
    {
      \int_gset:Nn \g_@@_output_int {\l_@@_tmpa_tl}
    }
    {
      \@@_crab_line:nn {t} {#2}
      \prop_gput:NnV \g_@@_answers_prop {CrabLineB} \g_@@_output_int
    }
  }
  \int_use:N \g_@@_output_int
  \int_gzero:N \g_@@_output_int
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{
% \DigitScramble
% }
%
% Digits to segments:
% \begin{itemize}
% \item 0 abcefg
% \item 1 cf
% \item 2 acdeg
% \item 3 acdfg
% \item 4 bcdf
% \item 5 abdfg
% \item 6 abdefg
% \item 7 acf
% \item 8 abcdefg
% \item 9 abcdfg
% \end{itemize}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_count_digits:n #1
{
  \group_begin:
%    \end{macrocode}
% Open the file and read in the data to a sequence.
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#1 .txt}
  {
%    \end{macrocode}
% Iterate through the file
%    \begin{macrocode}
    \int_zero:N \l_@@_tmpa_int
    \ior_map_inline:Nn \l_@@_tmpa_ior
    {
      \tl_set:Nn \l_@@_tmpa_tl {##1}
      \tl_trim_spaces:N \l_@@_tmpa_tl
      \seq_set_split:NnV \l_@@_tmpa_seq {~} \l_@@_tmpa_tl
      \prg_replicate:nn {11}
      {
        \seq_pop_left:NN \l_@@_tmpa_seq \l_@@_tmpa_tl
      }
      \seq_map_inline:Nn \l_@@_tmpa_seq
      {
        \bool_if:nT
        {
          \int_compare_p:nNn {\tl_count:n {####1}} < {5}
          ||
          \int_compare_p:nNn {\tl_count:n {####1}} = {7}
        }
        {
          \int_incr:N \l_@@_tmpa_int
        }
      }
    }
    \ior_close:N \l_@@_tmpa_ior
%    \end{macrocode}
%
%    \begin{macrocode}
    \int_gset_eq:NN \g_@@_output_int \l_@@_tmpa_int
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#1}
  }
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\NewDocumentCommand \DigitScramble {m}
{
  \prop_get:NnNTF \g_@@_answers_prop {DigitScramble} \l_@@_tmpa_tl
  {
    \int_gset:Nn \g_@@_output_int { \l_@@_tmpa_tl }
  }
  {
    \@@_count_digits:n {#1}
    \prop_gput:NnV \g_@@_answers_prop {DigitScramble} \g_@@_output_int
  }
  \int_use:N \g_@@_output_int
  \int_gzero:N \g_@@_output_int
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
% \DigitUnScramble
% }
%
% Digits to segments:
% \begin{itemize}
% \item 0 abcefg
% \item 1 cf
% \item 2 acdeg
% \item 3 acdfg
% \item 4 bcdf
% \item 5 abdfg
% \item 6 abdefg
% \item 7 acf
% \item 8 abcdefg
% \item 9 abcdfg
% \end{itemize}
%
% Number of times each segment is used
% \begin{itemize}
% \item a 8
% \item b 6
% \item c 8
% \item d 7
% \item e 4
% \item f 9
% \item g 7
% \end{itemize}
% The grand total of these is \(8 + 6 + 8 + 7 + 4 + 9 + 7 = 49\).
%
% So the ``Digit Sum'' of each is:
% \begin{itemize}
% \item 0 abcefg \(8 + 6 + 8 + 4 + 9 + 7 = 42\)
% \item 1 cf \(8 + 9 = 17\)
% \item 2 acdeg \(8 + 8 + 7 + 4 + 7 = 34\)
% \item 3 acdfg \(8 + 8 + 7 + 9 + 7 = 39\)
% \item 4 bcdf \(6 + 8 + 7 + 9 = 30\)
% \item 5 abdfg \(8 + 6 + 7 + 9 + 7 = 37\)
% \item 6 abdefg \(8 + 6 + 7 + 4 + 9 + 7 = 41\)
% \item 7 acf \(8 + 8 + 9 = 25\)
% \item 8 abcdefg \(8 + 6 + 8 + 7 + 4 + 9 + 7 = 49\)
% \item 9 abcdfg \(8 + 6 + 8 + 7 + 9 + 7 = 45\)
% \end{itemize}
% These are unique, so can be used to determine the code.
%
%    \begin{macrocode}
\prop_new:N \l_@@_digits_prop
\prop_put:Nnn \l_@@_digits_prop {42} {0}
\prop_put:Nnn \l_@@_digits_prop {17} {1}
\prop_put:Nnn \l_@@_digits_prop {34} {2}
\prop_put:Nnn \l_@@_digits_prop {39} {3}
\prop_put:Nnn \l_@@_digits_prop {30} {4}
\prop_put:Nnn \l_@@_digits_prop {37} {5}
\prop_put:Nnn \l_@@_digits_prop {41} {6}
\prop_put:Nnn \l_@@_digits_prop {25} {7}
\prop_put:Nnn \l_@@_digits_prop {49} {8}
\prop_put:Nnn \l_@@_digits_prop {45} {9}
\cs_new_protected_nopar:Npn \@@_unscramble_digits:n #1
{
  \group_begin:
%    \end{macrocode}
% Open the file and read in the data to a sequence.
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#1 .txt}
  {
%    \end{macrocode}
% Iterate through the file
%    \begin{macrocode}
    \int_zero:N \l_@@_tmpb_int
    \ior_map_inline:Nn \l_@@_tmpa_ior
    {
      \tl_set:Nn \l_@@_tmpa_tl {##1}
      \tl_trim_spaces:N \l_@@_tmpa_tl
      \seq_set_split:NnV \l_@@_tmpa_seq {~} \l_@@_tmpa_tl
      \tl_clear:N \l_@@_tmpa_tl
      \prg_replicate:nn {10}
      {
        \seq_pop_left:NN \l_@@_tmpa_seq \l_@@_tmpb_tl
        \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
      }
      \seq_pop_left:NN \l_@@_tmpa_seq \l_@@_tmpb_tl
      \tl_sort:Nn \l_@@_tmpa_tl
      {
        \int_compare:nNnTF { `####1 } > { `####2 }
        { \sort_return_swapped: }
        { \sort_return_same: }
      }

      \prop_clear:N \l_@@_tmpa_prop
      \int_zero:N \l_@@_tmpa_int
      \tl_set:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
      \tl_map_inline:Nn \l_@@_tmpa_tl
      {
        \exp_args:NV \tl_if_eq:nnTF \l_@@_tmpb_tl {####1}
        {
          \int_incr:N \l_@@_tmpa_int
        }
        {
          \prop_put:NVV \l_@@_tmpa_prop \l_@@_tmpb_tl \l_@@_tmpa_int
          \tl_set:Nn \l_@@_tmpb_tl {####1}
          \int_set:Nn \l_@@_tmpa_int {1}
        }
      }
      \prop_put:NVV \l_@@_tmpa_prop \l_@@_tmpb_tl \l_@@_tmpa_int

      \tl_clear:N \l_@@_tmpa_tl
      \seq_map_inline:Nn \l_@@_tmpa_seq
      {
        \int_zero:N \l_@@_tmpa_int
        \tl_map_inline:nn {####1}
        {
          \int_add:Nn \l_@@_tmpa_int {\prop_item:Nn \l_@@_tmpa_prop {########1}}
        }
        \tl_put_right:Nx \l_@@_tmpa_tl {\exp_args:NNV \prop_item:Nn \l_@@_digits_prop \l_@@_tmpa_int}
      }
      \int_add:Nn \l_@@_tmpb_int {\tl_use:N \l_@@_tmpa_tl}

    }
    \ior_close:N \l_@@_tmpa_ior
%    \end{macrocode}
%
%    \begin{macrocode}
    \int_gset_eq:NN \g_@@_output_int \l_@@_tmpb_int
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#1}
  }
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\NewDocumentCommand \DigitUnScramble {m}
{
  \prop_get:NnNTF \g_@@_answers_prop {DigitUnScramble} \l_@@_tmpa_tl
  {
    \int_gset:Nn \g_@@_output_int { \l_@@_tmpa_tl }
  }
  {
    \@@_unscramble_digits:n {#1}
    \prop_gput:NnV \g_@@_answers_prop {DigitUnScramble} \g_@@_output_int
  }
  \int_use:N \g_@@_output_int
  \int_gzero:N \g_@@_output_int
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{
% \SmokeBasin,
% \BasinSize
% }
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_check_line:Nnnn #1#2#3#4
{
  \int_step_inline:nnn {2} {\tl_count:n {#3} - 1}
  {
    \bool_if:nT
    {
      \int_compare_p:nNn
      {\tl_item:nn {#3} {##1}} < {\tl_item:nn {#3} {##1-1}}
      &&
      \int_compare_p:nNn
      {\tl_item:nn {#3} {##1}} < {\tl_item:nn {#3} {##1+1}}
      &&
      \int_compare_p:nNn
      {\tl_item:nn {#3} {##1}} < {\tl_item:nn {#2} {##1}}
      &&
      \int_compare_p:nNn
      {\tl_item:nn {#3} {##1}} < {\tl_item:nn {#4} {##1}}
    }
    {
      \int_add:Nn #1 {\tl_item:nn {#3} {##1} + 1}
    }
  }
}
\cs_generate_variant:Nn \@@_check_line:Nnnn {NVVV}
%    \end{macrocode}
%
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_smoke_basin:n #1
{
  \group_begin:
%    \end{macrocode}
% Open the file and read in the data to a sequence.
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#1 .txt}
  {
    \int_zero:N \l_@@_tmpa_int
%    \end{macrocode}
% Get the first line
%    \begin{macrocode}
    \ior_get:NN \l_@@_tmpa_ior \l_@@_tmpc_tl
%    \end{macrocode}
% Pad it with a \(10\) left and right
%    \begin{macrocode}
    \tl_put_right:Nn \l_@@_tmpc_tl {{10}}
    \tl_put_left:Nn \l_@@_tmpc_tl {{10}}
%    \end{macrocode}
% Create a ``border`` line of \(10\)s
%    \begin{macrocode}
    \tl_clear:N \l_@@_tmpb_tl
    \prg_replicate:nn {\tl_count:N \l_@@_tmpc_tl}
    {
      \tl_put_right:Nn \l_@@_tmpb_tl {{10}}
    }
%    \end{macrocode}
% Step through the file, each time shifting the lines down one
%    \begin{macrocode}
    \ior_map_inline:Nn \l_@@_tmpa_ior
    {
      \tl_set_eq:NN \l_@@_tmpa_tl \l_@@_tmpb_tl
      \tl_set_eq:NN \l_@@_tmpb_tl \l_@@_tmpc_tl
      \tl_set:Nn \l_@@_tmpc_tl {{10}##1{10}}

      \@@_check_line:NVVV
      \l_@@_tmpa_int \l_@@_tmpa_tl \l_@@_tmpb_tl \l_@@_tmpc_tl
    }
%    \end{macrocode}
% One line left to do
%    \begin{macrocode}
    \tl_set_eq:NN \l_@@_tmpa_tl \l_@@_tmpb_tl
    \tl_set_eq:NN \l_@@_tmpb_tl \l_@@_tmpc_tl
    \tl_clear:N \l_@@_tmpc_tl
    \prg_replicate:nn {\tl_count:N \l_@@_tmpb_tl}
    {
      \tl_put_right:Nn \l_@@_tmpc_tl {{10}}
    }
    \@@_check_line:NVVV
    \l_@@_tmpa_int \l_@@_tmpa_tl \l_@@_tmpb_tl \l_@@_tmpc_tl
    
    
    \ior_close:N \l_@@_tmpa_ior
    \int_gset_eq:NN \g_@@_output_int \l_@@_tmpa_int
%    \end{macrocode}
%
%    \begin{macrocode}
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#1}
  }
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\NewDocumentCommand \SmokeBasin {m}
{
  \prop_get:NnNTF \g_@@_answers_prop {SmokeBasin} \l_@@_tmpa_tl
  {
    \int_gset:Nn \g_@@_output_int { \l_@@_tmpa_tl }
  }
  {
    \@@_smoke_basin:n {#1}
    \prop_gput:NnV \g_@@_answers_prop {SmokeBasin} \g_@@_output_int
  }
  \int_use:N \g_@@_output_int
  \int_gzero:N \g_@@_output_int
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{
% \BasinSize
% }
%
%    \begin{macrocode}
\intarray_new:Nn \g_@@_basins_intarray {102*102}
\intarray_new:Nn \g_@@_flow_intarray {102*102}
\cs_new_protected_nopar:Npn \@@_basin_size:n #1
{
  \group_begin:
%    \end{macrocode}
% Open the file and read in the data to a sequence.
%    \begin{macrocode}
  \intarray_gzero:N \g_@@_basins_intarray
  \intarray_gzero:N \g_@@_flow_intarray
  \int_step_inline:nn {102}
  {
    \intarray_gset:Nnn \g_@@_basins_intarray {##1} {9}
  }
  \int_zero:N \l_@@_tmpa_int
  \int_incr:N \l_@@_tmpa_int
  \ior_open:NnTF \l_@@_tmpa_ior {#1 .txt}
  {
    \ior_map_inline:Nn \l_@@_tmpa_ior
    {
      \tl_set:Nn \l_@@_tmpa_tl {{9}##1{9}}
      \int_step_inline:nn {102}
      {
        \intarray_gset:Nnn \g_@@_basins_intarray {####1 + 102*\l_@@_tmpa_int} {\tl_item:Nn \l_@@_tmpa_tl {####1}}
        \int_compare:nNnF {\tl_item:Nn \l_@@_tmpa_tl {####1}} = {9}
        {
          \intarray_gset:Nnn \g_@@_flow_intarray {####1 + 102*\l_@@_tmpa_int} {1}
        }
      }
      \int_incr:N \l_@@_tmpa_int
    }

    \int_step_inline:nn {102}
    {
      \intarray_gset:Nnn \g_@@_basins_intarray {##1 + 102 * \l_@@_tmpa_int} {9}
    }


    \bool_set_true:N \l_@@_tmpa_bool

    \bool_while_do:Nn \l_@@_tmpa_bool
    {
      \bool_set_false:N \l_@@_tmpa_bool
      \int_step_inline:nnn {2} {101}
      {
        \int_step_inline:nnn {1} {100}
        {
          \int_compare:nNnT {\intarray_item:Nn \g_@@_flow_intarray {##1 + ####1 * 102} } > {0}
          {
            \int_compare:nNnTF {\intarray_item:Nn \g_@@_basins_intarray {##1 + ####1 * 102} } >  {\intarray_item:Nn \g_@@_basins_intarray {##1 + ####1 * 102 + 1} }
            {
              \intarray_gset:Nnn \g_@@_flow_intarray {##1 + ####1 * 102 + 1}
              {
                \intarray_item:Nn \g_@@_flow_intarray {##1 + ####1 * 102} +  \intarray_item:Nn \g_@@_flow_intarray {##1 + ####1 * 102 + 1}
              }
              \intarray_gset:Nnn \g_@@_flow_intarray {##1 + ####1 * 102} {0}
              \bool_set_true:N \l_@@_tmpa_bool
            }
            {
              \int_compare:nNnTF {\intarray_item:Nn \g_@@_basins_intarray {##1 + ####1 * 102} } >  {\intarray_item:Nn \g_@@_basins_intarray {##1 + ####1 * 102 - 1} }
              {
                \intarray_gset:Nnn \g_@@_flow_intarray {##1 + ####1 * 102 - 1}
                {
                  \intarray_item:Nn \g_@@_flow_intarray {##1 + ####1 * 102} +  \intarray_item:Nn \g_@@_flow_intarray {##1 + ####1 * 102 - 1}
                }
                \intarray_gset:Nnn \g_@@_flow_intarray {##1 + ####1 * 102} {0}
                \bool_set_true:N \l_@@_tmpa_bool
              }
              {
                \int_compare:nNnTF {\intarray_item:Nn \g_@@_basins_intarray {##1 + ####1 * 102} } >  {\intarray_item:Nn \g_@@_basins_intarray {##1 + (####1 + 1) * 102} }
                {
                  \intarray_gset:Nnn \g_@@_flow_intarray {##1 + (####1 + 1) * 102}
                  {
                    \intarray_item:Nn \g_@@_flow_intarray {##1 + ####1 * 102} +  \intarray_item:Nn \g_@@_flow_intarray {##1 + (####1 + 1) * 102 }
                  }
                  \intarray_gset:Nnn \g_@@_flow_intarray {##1 + ####1 * 102} {0}
                  \bool_set_true:N \l_@@_tmpa_bool
                }
                {
                  \int_compare:nNnTF {\intarray_item:Nn \g_@@_basins_intarray {##1 + ####1 * 102} } >  {\intarray_item:Nn \g_@@_basins_intarray {##1 + (####1 - 1) * 102} }
                  {
                    \intarray_gset:Nnn \g_@@_flow_intarray {##1 + (####1 - 1) * 102}
                    {
                      \intarray_item:Nn \g_@@_flow_intarray {##1 + ####1 * 102} +  \intarray_item:Nn \g_@@_flow_intarray {##1 + (####1 - 1) * 102 }
                    }
                    \intarray_gset:Nnn \g_@@_flow_intarray {##1 + ####1 * 102} {0}
                    \bool_set_true:N \l_@@_tmpa_bool
                  }
                  {
                  }
                }
              }
            }
          }
        }
      }
    }
    
    \seq_clear:N \l_@@_tmpa_seq
    \int_step_inline:nn {102*102}
    {
      \int_compare:nNnT {\intarray_item:Nn \g_@@_flow_intarray {##1}} > {0}
      {
        \seq_put_right:Nx \l_@@_tmpa_seq  {\intarray_item:Nn \g_@@_flow_intarray {##1}}
      }
    }
    \seq_sort:Nn \l_@@_tmpa_seq
    {
      \int_compare:nNnTF { ##1 } > { ##2 }
      { \sort_return_swapped: }
      { \sort_return_same: }
    }

    \int_set:Nn \l_@@_tmpa_int {1}
    \prg_replicate:nn {3}
    {
      \seq_pop_right:NN \l_@@_tmpa_seq \l_@@_tmpa_tl
      \int_set:Nn \l_@@_tmpa_int {\l_@@_tmpa_int * \l_@@_tmpa_tl}
    }

    \int_gset_eq:NN \g_@@_output_int \l_@@_tmpa_int

    \ior_close:N \l_@@_tmpa_ior
%    \end{macrocode}
%
%    \begin{macrocode}
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#1}
  }
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\NewDocumentCommand \BasinSize {m}
{
  \prop_get:NnNTF \g_@@_answers_prop {BasinSize} \l_@@_tmpa_tl
  {
    \int_gset:Nn \g_@@_output_int {\tl_use:N \l_@@_tmpa_tl}
  }
  {
    \@@_basin_size:n {#1}
    \prop_gput:NnV \g_@@_answers_prop {BasinSize} \g_@@_output_int
  }
  \int_use:N \g_@@_output_int
  \int_gzero:N \g_@@_output_int
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{
% \SyntaxScore
% }
%
%    \begin{macrocode}

\str_const:Nn \c_@@_left_bracket_str {[}
\str_const:Nn \c_@@_right_bracket_str {]}
\str_const:Nn \c_@@_left_parenthesis_str {(}
\str_const:Nn \c_@@_right_parenthesis_str {)}
\str_const:Nn \c_@@_left_angle_str {<}
\str_const:Nn \c_@@_right_angle_str {>}

\cs_new_protected_nopar:Npn \@@_syntax_scoring:n #1
{
  \group_begin:
  \iow_open:Nn \l_@@_tmpa_iow {Day10-sequences.txt}
%    \end{macrocode}
% Open the file and step through it line by line.
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#1 .txt}
  {
%    \end{macrocode}
% These are the two scores, the integer register is for corrupt lines and the sequences are for the incompletes (need two as we get overflow).
%    \begin{macrocode}
    \int_zero:N \l_@@_tmpa_int
    \seq_clear:N \l_@@_tmpa_seq
    \seq_clear:N \l_@@_tmpb_seq
    \ior_str_map_inline:Nn \l_@@_tmpa_ior
    {
%    \end{macrocode}
% As we step through the line, this string will hold what we're expecting to see in terms of closing symbols.
%    \begin{macrocode}
      \str_clear:N \l_@@_tmpa_str
      \str_map_inline:nn {##1}
      {
%    \end{macrocode}
% Test the next character, if it is an opening symbol then append the corresponding closing symbol to the tail string.
%    \begin{macrocode}
        \str_case_e:nnF {####1}
        {
          {\c_@@_left_parenthesis_str} {\str_put_left:NV \l_@@_tmpa_str \c_@@_right_parenthesis_str}
          {\c_@@_left_bracket_str} {\str_put_left:NV \l_@@_tmpa_str \c_@@_right_bracket_str}
          {\c_left_brace_str} {\str_put_left:NV \l_@@_tmpa_str \c_right_brace_str}
          {\c_@@_left_angle_str} {\str_put_left:NV \l_@@_tmpa_str \c_@@_right_angle_str}
        }
%    \end{macrocode}
% If it is a closing symbol, then we check to see if it matches the symbol that we're expecting.
% If it does, simply remove it from the tail string.
%    \begin{macrocode}
        {
          \str_if_eq:eeTF {####1} {\str_head:N \l_@@_tmpa_str}
          {
            \str_set:Nx \l_@@_tmpa_str {\str_tail:N \l_@@_tmpa_str}
          }
          {
%    \end{macrocode}
% If it does not match, then it is a corrupt line and so we add the score to the running total.
%    \begin{macrocode}
            \str_case_e:nn {####1}
            {
              {\c_@@_right_parenthesis_str} {\int_add:Nn \l_@@_tmpa_int {3}}
              {\c_@@_right_bracket_str} {\int_add:Nn \l_@@_tmpa_int {57}}
              {\c_right_brace_str} {\int_add:Nn \l_@@_tmpa_int {1197}}
              {\c_@@_right_angle_str} {\int_add:Nn \l_@@_tmpa_int {25137}}
            }
%    \end{macrocode}
% If it is corrupt, quit the innermost loop.
% We clear the tail string as well so that it doesn't also count as incomplete.
%    \begin{macrocode}
            \str_clear:N \l_@@_tmpa_str
            \str_map_break:
          }
        }
      }
%    \end{macrocode}
% Map through the tail, adding the scores.
% We hit overflow so we need to use doubles.
%    \begin{macrocode}
      \int_zero:N \l_@@_tmpb_int
      \int_zero:N \l_@@_tmpc_int
      \exp_args:NNV \iow_now:Nn  \l_@@_tmpa_iow \l_@@_tmpa_str

      \str_map_inline:Nn \l_@@_tmpa_str
      {
        \int_set:Nn \l_@@_tmpb_int { \l_@@_tmpb_int * 5 }
        \int_set:Nn \l_@@_tmpc_int { \l_@@_tmpc_int * 5 }
        \str_case_e:nn {####1}
        {
          {\c_@@_right_parenthesis_str} {\int_add:Nn \l_@@_tmpb_int {1}}
          {\c_@@_right_bracket_str} {\int_add:Nn \l_@@_tmpb_int {2}}
          {\c_right_brace_str} {\int_add:Nn \l_@@_tmpb_int {3}}
          {\c_@@_right_angle_str} {\int_add:Nn \l_@@_tmpb_int {4}}
        }
        
        \int_while_do:nNnn {\l_@@_tmpb_int} > {\c_@@_overflow_int-1}
        {
          \int_incr:N \l_@@_tmpc_int
          \int_sub:Nn \l_@@_tmpb_int {\c_@@_overflow_int}
        }
      }
      \bool_if:nT
      {
        \int_compare_p:nNn {\l_@@_tmpb_int} > {0}
        ||
        \int_compare_p:nNn {\l_@@_tmpc_int} > {0}
      }
      {
        \double_int_to_tl:NNN \l_@@_tmpa_tl \l_@@_tmpc_int \l_@@_tmpb_int
        \seq_put_right:NV \l_@@_tmpa_seq \l_@@_tmpa_tl
      }
    }
%    \end{macrocode}
% Sort the sequence to make it possible to find the median
%    \begin{macrocode}
    \int_zero:N \l_@@_tmpb_int
    \seq_map_inline:Nn \l_@@_tmpa_seq
    {
      \int_set:Nn \l_@@_tmpb_int {\int_max:nn{\l_@@_tmpb_int}{\tl_count:n {##1}}}
    }

    \seq_clear:N \l_@@_tmpb_seq
    \seq_map_inline:Nn \l_@@_tmpa_seq
    {
      \str_clear:N \l_@@_tmpa_str
      \prg_replicate:nn {\l_@@_tmpb_int - \tl_count:n {##1}}
      {
        \str_put_right:Nn \l_@@_tmpa_str {0}
      }
      \str_put_right:Nn \l_@@_tmpa_str {##1}
      \seq_put_right:NV \l_@@_tmpb_seq \l_@@_tmpa_str
    }

    \seq_sort:Nn \l_@@_tmpb_seq
    {
      \str_compare:nNnTF { ##1 } > { ##2 }
      { \sort_return_swapped: }
      { \sort_return_same: }
    }

    \tl_set:Nx \l_@@_tmpa_tl {\seq_item:Nn \l_@@_tmpb_seq {(1 + \seq_count:N \l_@@_tmpb_seq)/2}}
    \tl_set:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
    \tl_set:Nn \l_@@_tmpc_tl {0}
    \bool_while_do:nn
    {
      \tl_if_eq_p:NN \l_@@_tmpb_tl \l_@@_tmpc_tl
    }
    {
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
    }

    \tl_gset:Nx \g_@@_output_tl
    {
      {\int_use:N \l_@@_tmpa_int}
      {\tl_use:N \l_@@_tmpa_tl}
    }
  
    \iow_close:N \l_@@_tmpa_iow
    \ior_close:N \l_@@_tmpa_ior
%    \end{macrocode}
%
%    \begin{macrocode}
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#1}
  }
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\NewDocumentCommand \SyntaxScore {s m}
{
  \prop_get:NnNTF \g_@@_answers_prop {SyntaxScore} \l_@@_tmpa_tl
  {
    \tl_gset_eq:NN \g_@@_output_tl {\tl_use:N \l_@@_tmpa_tl }
  }
  {
    \@@_syntax_scoring:n {#2}
%    \prop_gput:NnV \g_@@_answers_prop {SyntaxScore} \g_@@_output_tl
  }
  \IfBooleanTF {#1}
  {
    \tl_item:Nn \g_@@_output_tl {1}
  }
  {
    \tl_item:Nn \g_@@_output_tl {2}
  }

  \tl_gclear:N \g_@@_output_tl
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{
% \OctopusFlash
% }
%
%    \begin{macrocode}
\intarray_new:Nn \g_@@_octopus_intarray {10*10}
\intarray_new:Nn \g_@@_flash_intarray {10*10}
\seq_const_from_clist:Nn \c_@@_neighbours_seq {-11,-10,-9,-1,1,9,10,11}
\cs_new_protected_nopar:Npn \@@_octopus_flash:nn #1#2
{
  \group_begin:
%    \end{macrocode}
% Open the file and read in the data to a sequence.
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#2 .txt}
  {
    \int_zero:N \l_@@_tmpa_int
    \ior_map_inline:Nn \l_@@_tmpa_ior
    {
      \tl_map_inline:nn {##1}
      {
        \int_incr:N \l_@@_tmpa_int
        \intarray_gset:Nnn \g_@@_octopus_intarray {\l_@@_tmpa_int} {####1}
      }
    }
    \ior_close:N \l_@@_tmpa_ior
%    \end{macrocode}
%
%    \begin{macrocode}
    \int_zero:N \l_@@_tmpa_int
    \int_zero:N \l_@@_tmpb_int
    \int_zero:N \l_@@_tmpc_int
    \tl_if_eq:nnTF {#1} {0}
    {
      \prg_replicate:nn {100}
    }
    {
      \bool_while_do:nn
      {
        \int_compare_p:nNn { \l_@@_tmpc_int } = {0}
      }
    }
    {
      \int_incr:N \l_@@_tmpb_int
%    \end{macrocode}
% Building the step procedure, clear the grid of octopodes which have flashed.
%    \begin{macrocode}
      \intarray_gzero:N \g_@@_flash_intarray
      \int_step_inline:nn {100}
      {
%    \end{macrocode}
%
% Increment the energy levels.
%    \begin{macrocode}
        \intarray_gset:Nnn \g_@@_octopus_intarray {##1} {\intarray_item:Nn \g_@@_octopus_intarray {##1} + 1}
      }
%    \end{macrocode}
% Now we iterate through the grid looking for octopusses that are above the threshold.
%    \begin{macrocode}
      \bool_set_true:N \l_@@_tmpa_bool
      \bool_while_do:Nn \l_@@_tmpa_bool
      {
        \bool_set_false:N \l_@@_tmpa_bool
        \int_step_inline:nn {100}
        {
%    \end{macrocode}
% Check if this octopus has enough energy and hasn't already flashed on this iteration.
%    \begin{macrocode}
          \bool_if:nT
          {
            \int_compare_p:nNn {\intarray_item:Nn \g_@@_octopus_intarray {##1}} > {9}
            &&
            \int_compare_p:nNn {\intarray_item:Nn \g_@@_flash_intarray {##1}} = {0}
          }
          {
%    \end{macrocode}
% We got a live one!
%    \begin{macrocode}
            \int_incr:N \l_@@_tmpa_int
            \bool_set_true:N \l_@@_tmpa_bool
            \intarray_gset:Nnn \g_@@_flash_intarray {##1} {1}
%    \end{macrocode}
% Now we need to increment the energies of the neighbours
%    \begin{macrocode}
            \seq_map_inline:Nn \c_@@_neighbours_seq
            {
%    \end{macrocode}
% Test to see if this octopus is on the grid
%    \begin{macrocode}
              \bool_if:nTF
              {
%    \end{macrocode}
% Bottom edge
%    \begin{macrocode}
                \int_compare_p:nNn {##1 + ####1} < {1}
                ||
%    \end{macrocode}
% Top edge
%    \begin{macrocode}
                \int_compare_p:nNn {##1 + ####1} > {100}
                ||
%    \end{macrocode}
% Left edge
%    \begin{macrocode}
                \int_compare_p:nNn {\int_mod:nn {##1-1}{10} + \int_mod:nn {####1+21}{10}-1 } < {0}
                ||
%    \end{macrocode}
% Right edge
%    \begin{macrocode}
                \int_compare_p:nNn {\int_mod:nn {##1-1}{10} + \int_mod:nn {####1+21}{10}-1 } > {9}
              }
              {
%                \tl_show:x {##1,####1,\int_eval:n {##1 + ####1},\int_eval:n {\int_mod:nn {##1-1}{10} + \int_mod:nn {####1+21}{10}-1 }}
              }
              {
%    \end{macrocode}
% Yes, so increment its energy
%    \begin{macrocode}
                \intarray_gset:Nnn \g_@@_octopus_intarray {##1 + ####1} {\intarray_item:Nn \g_@@_octopus_intarray {##1 + ####1} + 1}
              }
            }
          }
        }
%    \end{macrocode}
% Now that we've processed all the current octopides, reset the ones that have flashed.
% Also check to see whether they all did or not.
%    \begin{macrocode}
        \bool_set_true:N \l_@@_tmpb_bool
        \int_step_inline:nn {100}
        {
          \int_compare:nNnTF {\intarray_item:Nn \g_@@_flash_intarray {##1}} = {1}
          {
            \intarray_gset:Nnn \g_@@_octopus_intarray {##1} {0}
          }
          {
            \bool_set_false:N \l_@@_tmpb_bool
          }
        }
        \bool_if:nT
        {
          \l_@@_tmpb_bool
          &&
          \int_compare_p:nNn {\l_@@_tmpc_int} = {0}
        }
        {
          \int_set_eq:NN \l_@@_tmpc_int \l_@@_tmpb_int
        }
      }
    }
%    \end{macrocode}
% Display the grid
%    \begin{macrocode}
%    \int_step_inline:nn {100}
%    {
%      \intarray_item:Nn \g_@@_octopus_intarray {##1}
%      \int_compare:nNnT {\int_mod:nn {##1}{10}} = {0}
%      {
%        \\
%      }
%    }
    \tl_if_eq:nnTF {#1} {0}
    {
      \int_gset_eq:NN \g_@@_output_int \l_@@_tmpa_int
    }
    {
      \int_gset_eq:NN \g_@@_output_int \l_@@_tmpc_int
    }

  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#2}
  }
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\NewDocumentCommand \OctopusFlash {s m}
{
  \IfBooleanTF {#1}
  {
    \prop_get:NnNTF \g_@@_answers_prop {OctopusFlash} \l_@@_tmpa_tl
    {
      \int_gset:Nn \g_@@_output_int {\tl_use:N \l_@@_tmpa_tl}
    }
    {
      \@@_octopus_flash:nn {0} {#2}
      \prop_gput:NnV \g_@@_answers_prop {OctopusFlash} \g_@@_output_int
    }
  }
  {
    \prop_get:NnNTF \g_@@_answers_prop {OctopusAllFlash} \l_@@_tmpa_tl
    {
      \int_gset:Nn \g_@@_output_int {\tl_use:N \l_@@_tmpa_tl}
    }
    {
      \@@_octopus_flash:nn {1} {#2}
%    \prop_gput:NnV \g_@@_answers_prop {OctopusAllFlash} \g_@@_output_int
    }
  }
  \int_use:N \g_@@_output_int
  \int_gzero:N \g_@@_output_int
}
%    \end{macrocode}
% \end{macro}
%
%
% \iffalse
%</advent>
% \fi
%
%
% \iffalse
%<*template>
% \fi
%
% \begin{macro}{
% \advent_template
% }
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_template:nn #1#2
{
  \group_begin:
%    \end{macrocode}
% Open the file and read in the data to a sequence.
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#2 .txt}
  {
    \ior_get:NN \l_@@_tmpa_ior \l_@@_tmpa_tl
    \ior_close:N \l_@@_tmpa_ior
%    \end{macrocode}
%
%    \begin{macrocode}
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#2}
  }
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\NewDocumentCommand \Template {m}
{
  \prop_get:NnNTF \g_@@_answers_prop {Template} \l_@@_tmpa_tl
  {
    \tl_gset_eq:NN \g_@@_output_tl \l_@@_tmpa_tl
  }
  {

    \prop_gput:NnV \g_@@_answers_prop {Template} \g_@@_output_tl
  }
  \tl_use:N \g_@@_output_tl
  \tl_gclear:N \g_@@_output_tl
}
%    \end{macrocode}
% \end{macro}
%
%
% \iffalse
%</template>
% \fi
%\Finale
\endinput
