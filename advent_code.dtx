% \iffalse meta-comment
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
Advent of Code 2021 --- LaTeX3 code for solving the Advent of Code 2021
E-mail: loopspace@mathforge.org
Released under the MIT Licence
----------------------------------------------------------------

This is code I've written in LaTeX3 for solving the problems of the Advent of Code 2021
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input l3docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
Advent of Code 2021 --- Functions for solving the problems
E-mail: loopspace@mathforge.org
Released under the MIT Licence
----------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2021 by Andrew Stacey <loopspace@mathforge.org>

This work may be distributed and/or modified under the
conditions of the MIT License

This work consists of the files  advent_code.dtx
and the derived files            advent.ins,
                                 advent_code.pdf,
                                 advent.sty,

\endpostamble
\usedir{tex/latex/advent}
\generate{
  \file{advent.sty}{\from{\jobname.dtx}{advent}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/advent}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
\documentclass[full]{l3doc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
%\usepackage{morefloats}
\usepackage{trace}
\usepackage{advent}
%\traceoff
%\usepackage[numbered]{hypdoc}
\definecolor{lstbgcolor}{rgb}{0.9,0.9,0.9} 
 
\usepackage{listings}
\lstloadlanguages{[LaTeX]TeX}
\lstset{
  breakatwhitespace=true,
  breaklines=true,
  language=[LaTeX]TeX,
  basicstyle=\small\ttfamily,
  keepspaces=true,
  columns=fullflexible
}
 
\usepackage{fancyvrb}

\newenvironment{example}
  {\VerbatimEnvironment
   \begin{VerbatimOut}[gobble=2]{example.out}}
  {\end{VerbatimOut}
   \begin{center}
%   \setlength{\parindent}{0pt}
   \fbox{\begin{minipage}{.9\linewidth}
     \lstinputlisting[]{example.out}
   \end{minipage}}
   \fbox{\begin{minipage}{.9\linewidth}
     \centering
     \input{example.out}
   \end{minipage}}
\end{center}
}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{1.00}{2021/12/05}{Created DTX file}
%
% \DoNotIndex{\newcommand,\newenvironment}
%
% \pdfstringdefDisableCommands{%
%  \def\\{}%
%  \def\url#1{<#1>}%
% }
%
% \providecommand*{\url}{\texttt}
% \GetFileInfo{advent.sty}
% \title{Advent of Code 2021: \LaTeX3 Solutions}
% \author{Andrew Stacey \\ \url{loopspace@mathforge.org}}
% \date{\fileversion~from \filedate}
%
%
% \maketitle
%
% 
% \section{Introduction}
%
% \section{Day 01}
%
% \begin{function}{\CountIncreases}
%
% For this, we take advantage of a useful thing with the rolling averages.
% If the first four terms are \(a\), \(b\), \(c\), and \(d\) then the first rolling average is \(a + b + c\) and the second is \(b + c + d\), so when comparing these averages it is enough to compare \(a\) with \(d\).
% So we store \(k\) items in a sequence and then compare the next item with the first term of that sequence.
% By then putting that next item on the end of the sequence and removing the first, so that it always stores the most recent \(k\) terms in the main list, we can iterate over the whole list quite efficiently.
%
% \begin{enumerate}
% \item There are \CountIncreases{Day01} increases in the depths.
% \item There are \CountIncreases[3]{Day01} increases in the \(3\)--item rolling averages of the depths.
% \end{enumerate}
% \end{function}
%
% \section{Day 02}
%
% For the second task, we can reuse the code since the \Verb!Depth! of the first part now becomes the \Verb!Aim! of the second.
% So it is just a matter of adding the extra counter to the main code and then selecting the right outputs for the user level command.
%
% \begin{function}{\NavigateSub}
% \begin{enumerate}
% \item \NavigateSub*{Day02}
% \item \NavigateSub{Day02}
% \end{enumerate}
% \end{function}
%
% \section{Day 03}
%
% I didn't originally see how to directly use my code from the first part in solving the second.
% Eventually, I hit on the idea of iterating through the list of data with a filter and figuring out the frequency of each bit for those which match the filter.
% For the first part, the filter is just ``allow everything'' but for the second then we gradually build up a prefix to match against.
% The \(\mathrm{CO}_2\) count proved slightly tricky due to the condition that once we have only a single match then we return that.
% With the \(\mathrm{O}_2\) count then we can continue looking for the most frequent bit value even when there's only one left.
% But with the \(\mathrm{CO}_2\) count then we need to flip the behaviour when there's only one left.
%
% \begin{function}{\CalculateRatesGE,\CalculateRatesOCO}
% \begin{enumerate}
% \item \CalculateRatesGE{Day03}
% \item \CalculateRatesOCO{Day03}
% \end{enumerate}
% \end{function}
% 
% 
% \StopEventually{}
%
% \section{Implementation}
%
% \iffalse
%<*advent>
% \fi
% \subsection{Initialisation}
%
%    \begin{macrocode}
%<@@=advent>
%    \end{macrocode}
%
% Load the \LaTeX3 foundation and register us as a \LaTeX3\ package.
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{expl3}
\ProvidesExplPackage {advent} {2021/12/05} {1.00} {Functions for
solving the Advent of Code 2021}
\RequirePackage{xparse}
%    \end{macrocode}
%
% Utilities copied from \url{https://github.com/loopspace/LaTeX3-Utilities} for adding something in braces to a token list.
% I find I use this quite a lot in my packages.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_tl_put_right_braced:Nn
{
  \tl_put_right:Nn #1 { { #2 } }
}
\cs_generate_variant:Nn \@@_tl_put_right_braced:Nn { NV, cV, cv, Nx, cx }

\cs_new_protected:Nn \@@_tl_gput_right_braced:Nn
{
  \tl_gput_right:Nn #1 { { #2 } }
}
\cs_generate_variant:Nn \@@_tl_gput_right_braced:Nn { NV, cV, cv, Nx, cx }
\cs_new_protected:Nn \@@_tl_put_left_braced:Nn
{
  \tl_put_left:Nn #1 { { #2 } }
}
\cs_generate_variant:Nn \@@_tl_put_left_braced:Nn { NV, cV, cv, Nx, cx }

\cs_new_protected:Nn \@@_tl_gput_left_braced:Nn
{
  \tl_gput_left:Nn #1 { { #2 } }
}
\cs_generate_variant:Nn \@@_tl_gput_left_braced:Nn { NV, cV, cv, Nx, cx }
%    \end{macrocode}
%
%
% I had to think a bit about how to get \TeX\ to work the way I wanted.
% I'm really defining \emph{functions} but \TeX\ doesn't really have that concept, even with all the amazing \LaTeX3 stuff.
% The main issue I had was with scoping and return values.
% By default, \TeX\ functions aren't scoped -- they work on the same level as the calling functions.
% To protect the internals from being overwritten, each core function works inside a group.
% But then I have to work to get the answer out of it.
% So each of my core functions finishes by storing its return value in an appropriate \Verb+output+ variable.
% The core functions are then wrapped in a more user friendly interface that will take that output and assign it to a variable.
% This also means that I can deal with local and global versions without duplicating code.
%
%    \begin{macrocode}
\tl_new:N \g_@@_output_tl
\int_new:N \g_@@_output_int
\seq_new:N \g_@@_output_seq
\bool_new:N \g_@@_output_bool
%    \end{macrocode}
%
% To avoid creating vast numbers of variables, we provide ourselves with a few that we reuse frequently.
% For that reason, most of them don't have very exciting names.
%
% These are general purpose variables.
%    \begin{macrocode}
\tl_new:N \l_@@_tmpa_tl
\tl_new:N \l_@@_tmpb_tl
\tl_new:N \l_@@_tmpc_tl
\tl_new:N \l_@@_tmpd_tl
\tl_new:N \l_@@_tmpe_tl
\tl_new:N \l_@@_tmpf_tl
\tl_new:N \l_@@_tmpg_tl
\tl_new:N \l_@@_tmph_tl
\tl_new:N \l_@@_tmpi_tl

\seq_new:N \l_@@_tmpa_seq
\seq_new:N \l_@@_tmpb_seq
\seq_new:N \l_@@_tmpc_seq

\dim_new:N \l_@@_tmpa_dim
\dim_new:N \l_@@_tmpb_dim

\fp_new:N \l_@@_tmpa_fp
\fp_new:N \l_@@_tmpb_fp
\fp_new:N \l_@@_tmpc_fp
\fp_new:N \l_@@_tmpd_fp
\fp_new:N \l_@@_tmpe_fp
\fp_new:N \l_@@_tmpf_fp

\int_new:N \l_@@_tmpa_int
\int_new:N \l_@@_tmpb_int
\int_new:N \l_@@_tmpc_int

\bool_new:N \l_@@_tmpa_bool

\ior_new:N \l_@@_tmpa_ior

\msg_new:nnn { advent } { missing file } { File~ #1~ doesn't~ exist~ \msg_line_context:}

%    \end{macrocode}
%
% \begin{macro}{
% \CountIncreases
% }
% Take in a file of integers and count the changes.
% The second argument contains the step for the comparisons, so that the \(n\)th term is compared with the \(n+k\)th term.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_count_increases:nn #1#2
{
  \group_begin:
%    \end{macrocode}  
% Try to open the data file
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#1 .txt}
  {
%    \end{macrocode}  
% That was successful, so now initialise the count and a sequence which will hold the first \(k\) terms.
%    \begin{macrocode}
    \int_zero:N \l_@@_tmpa_int
    \seq_clear:N \l_@@_tmpa_seq
%    \end{macrocode}  
% Load in the first \(k\) lines of the file into the sequence.
%    \begin{macrocode}
    \int_step_inline:nnn {1} {#2}
    {
      \ior_get:NN \l_@@_tmpa_ior \l_@@_tmpa_tl
      \seq_put_right:NV \l_@@_tmpa_seq \l_@@_tmpa_tl
    }
%    \end{macrocode}  
% Now step through the rest of the file, comparing each value with the first value in the sequence of saved items (which we pop off the sequence).
%    \begin{macrocode}
    \ior_map_inline:Nn \l_@@_tmpa_ior
    {
%    \end{macrocode}  
% Start by removing the initial element in the sequence
%    \begin{macrocode}
      \seq_pop:NN \l_@@_tmpa_seq \l_@@_tmpb_tl
%    \end{macrocode}
% Compare that with the current item
%    \begin{macrocode}
      \int_compare:nNnT {##1} > {\l_@@_tmpb_tl}
      {
%    \end{macrocode}
% New term is bigger, so increment the counter
%    \begin{macrocode}     
        \int_incr:N \l_@@_tmpa_int
      }
%    \end{macrocode}
% Now store the new term on the end of the sequence.
%    \begin{macrocode}
      \seq_put_right:Nn \l_@@_tmpa_seq {##1}
    }
%    \end{macrocode}
% Save the count of increments in the output register and close the file.
%    \begin{macrocode}
    \int_gset_eq:NN \g_@@_output_int \l_@@_tmpa_int
    \ior_close:N \l_@@_tmpa_ior
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#1}
  }
  \group_end:
}
%    \end{macrocode}
% Wrap the above in a user command.
%    \begin{macrocode}
\NewDocumentCommand \CountIncreases {O{1} m}
{
  \@@_count_increases:nn {#2}{#1}
  \int_use:N \g_@@_output_int
  \int_gzero:N \g_@@_output_int
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
% \NavigateSub
% }
%
%    \begin{macrocode}
\tl_new:N \c_@@_forward_tl
\tl_new:N \c_@@_up_tl
\tl_new:N \c_@@_down_tl
\tl_gset:Nn \c_@@_forward_tl {forward}
\tl_gset:Nn \c_@@_up_tl {up}
\tl_gset:Nn \c_@@_down_tl {down}
\cs_new_protected_nopar:Npn \@@_navigate_sub:n #1
{
  \group_begin:
%    \end{macrocode}  
% Try to open the data file
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#1 .txt}
  {
%    \end{macrocode}  
% That was successful, so initialise the counters and start slurping through the file.
% The counters track:
% \begin{enumerate}
% \item \Verb!\l_@@_tmpa_int! Aim
% \item \Verb!\l_@@_tmpb_int! Horizontal distance
% \item \Verb!\l_@@_tmpc_int! Depth
% \end{enumerate}
%    \begin{macrocode}
    \int_zero:N \l_@@_tmpa_int
    \int_zero:N \l_@@_tmpb_int
    \int_zero:N \l_@@_tmpc_int

    \ior_map_inline:Nn \l_@@_tmpa_ior
    {
%    \end{macrocode}
% Read in a line, and split it into the command and amount.
%    \begin{macrocode}
      \seq_set_split:Nnn \l_@@_tmpa_seq {~} {##1}
      \seq_pop:NN \l_@@_tmpa_seq \l_@@_tmpa_tl
      \seq_pop:NN \l_@@_tmpa_seq \l_@@_tmpb_tl
%    \end{macrocode}
% Check the command and modify the appropriate counter
%    \begin{macrocode}
      \tl_case:Nn \l_@@_tmpa_tl
      {
        \c_@@_up_tl
        {
          \int_sub:Nn \l_@@_tmpa_int {\l_@@_tmpb_tl}
        }
        \c_@@_down_tl
        {
          \int_add:Nn \l_@@_tmpa_int {\l_@@_tmpb_tl}
        }
        \c_@@_forward_tl
        {
          \int_add:Nn \l_@@_tmpb_int {\l_@@_tmpb_tl}
          \int_add:Nn \l_@@_tmpc_int {(\l_@@_tmpb_tl) * (\l_@@_tmpa_int)}
        }
      }
    }
%    \end{macrocode}
% Now save the two counters into the output register.
%    \begin{macrocode}    
    \tl_gset:Nx \g_@@_output_tl {
      { \int_use:N \l_@@_tmpa_int }
      { \int_use:N \l_@@_tmpb_int }
      { \int_use:N \l_@@_tmpc_int }
    }
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#1}
  }
  \group_end:
}
%    \end{macrocode}
% Wrap the above in a user command.
%    \begin{macrocode}
\NewDocumentCommand \NavigateSub {s m}
{
  \@@_navigate_sub:n {#2}
  \IfBooleanTF {#1}
  {
    \tl_set:Nn \l_@@_tmpa_tl {1}
  }
  {
    \tl_set:Nn \l_@@_tmpa_tl {3}
  }
  \begin{itemize}
\item Depth:~\tl_item:Nn \g_@@_output_tl {\l_@@_tmpa_tl}
\item Distance:~\tl_item:Nn \g_@@_output_tl {2}
\item Product:~\int_eval:n { (\tl_item:Nn \g_@@_output_tl {\l_@@_tmpa_tl}) * (\tl_item:Nn \g_@@_output_tl {2})}
  \end{itemize}
  \tl_gclear:N \g_@@_output_tl
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{
% \CalculateRatesGE,
% \CalculateRatesOCO
% }
%
%    \begin{macrocode}
\int_const:Nn\c_@@_bitlength_int {12}
\cs_new_protected_nopar:Npn \@@_calculate_rate:nn #1#2
{
  \group_begin:
%    \end{macrocode}  
% Try to open the data file
%    \begin{macrocode}
  \ior_open:NnTF \l_@@_tmpa_ior {#2 .txt}
  {
%    \end{macrocode}
% Initialise the sequence that will track the most common values in each bit location.
%    \begin{macrocode}
    \seq_clear:N \l_@@_tmpa_seq
    \int_step_inline:nnn {1} {\c_@@_bitlength_int}
    {
      \seq_put_right:Nn \l_@@_tmpa_seq {0}
    }
%    \end{macrocode}
% We need to know if we have more than one match on the list
%    \begin{macrocode}
    \int_zero:N \l_@@_tmpa_int
%    \end{macrocode}
% Iterate through the file
%    \begin{macrocode}
    \ior_map_inline:Nn \l_@@_tmpa_ior
    {
%    \end{macrocode}
% We test if the line starts with the filter prefix.
% To force a match only at the start of the token lists, we prepend them both with an \Verb!X!.
%    \begin{macrocode}
      \tl_if_in:nnT {X##1} {X#1}
      {
        \int_incr:N \l_@@_tmpa_int
%    \end{macrocode}
% Iterate through binary number.
% If we get a \(1\) then we increment the count for this digit, if we get a \(0\) then we decrement it.      
% This way, if the final tally is positive then we want a \(1\) and if negative a \(0\).
%    \begin{macrocode}
        \seq_clear:N \l_@@_tmpb_seq
        \int_step_inline:nnn {1} {\c_@@_bitlength_int}
        {
          \seq_put_right:Nx \l_@@_tmpb_seq
          {
            \int_eval:n
            {
              \seq_item:Nn \l_@@_tmpa_seq {####1}
              +
              2*(\tl_item:nn {##1} {####1}) - 1
            }
          }
        }
        \seq_set_eq:NN \l_@@_tmpa_seq \l_@@_tmpb_seq
      }
    }
    \ior_close:N \l_@@_tmpa_ior
    \seq_gset_eq:NN \g_@@_output_seq \l_@@_tmpa_seq
    \bool_gset:Nn \g_@@_output_bool
    {
      \int_compare_p:nNn {\l_@@_tmpa_int} > {1}
    }
  }
  {
%    \end{macrocode}
% This gets invoked if there was a problem with opening the file.
%    \begin{macrocode}
    \msg_warning:nnn { advent } { missing file } {#1}
  }
  \group_end:
}
%    \end{macrocode}
% Wrap the above in user commands.
%
% Calculating the Gamma and Epsilon rates is straight-forward.
%    \begin{macrocode}
\NewDocumentCommand \CalculateRatesGE {m}
{
  \@@_calculate_rate:nn {} {#1}
  \int_zero:N \l_@@_tmpa_int
  \seq_map_inline:Nn \g_@@_output_seq
  {
    \int_set:Nn \l_@@_tmpa_int {2 * \l_@@_tmpa_int}
    \int_compare:nNnT {##1} > {0}
    {
      \int_incr:N \l_@@_tmpa_int
    }
  }
  \begin{itemize}
  \item Gamma~rate:~\int_use:N \l_@@_tmpa_int
\item Epsilon~rate:~\int_eval:n {4095 - \l_@@_tmpa_int}
\item Power~consumption:~ \int_eval:n {\l_@@_tmpa_int * (4095 - \l_@@_tmpa_int)}
  \end{itemize}
  \int_zero:N \l_@@_tmpa_int
  \seq_gclear:N \g_@@_output_seq
}
%    \end{macrocode}
%
% Calculating the Oxygen and Carbon-Dioxide is a little trickier.
%    \begin{macrocode}
\cs_generate_variant:Nn \@@_calculate_rate:nn {Vn}
\NewDocumentCommand \CalculateRatesOCO {m}
{
  \tl_clear:N \l_@@_tmpa_tl
  \int_step_inline:nnn {1} {\c_@@_bitlength_int}
  {
    \@@_calculate_rate:Vn \l_@@_tmpa_tl {#1}
    \int_compare:nNnTF {\seq_item:Nn \g_@@_output_seq {##1}} < {0}
    {
      \tl_put_right:Nn \l_@@_tmpa_tl {0}
    }
    {
      \tl_put_right:Nn \l_@@_tmpa_tl {1}
    }
  }
  \int_zero:N \l_@@_tmpa_int
  \tl_map_inline:Nn \l_@@_tmpa_tl
  {
    \int_set:Nn \l_@@_tmpa_int {2 * \l_@@_tmpa_int}
    \int_compare:nNnT {##1} > {0}
    {
      \int_incr:N \l_@@_tmpa_int
    }
  }
  \tl_clear:N \l_@@_tmpa_tl
  \int_step_inline:nnn {1} {\c_@@_bitlength_int}
  {
    \@@_calculate_rate:Vn \l_@@_tmpa_tl {#1}
    \bool_if:NTF \g_@@_output_bool
    {
      \int_compare:nNnTF {\seq_item:Nn \g_@@_output_seq {##1}} < {0}
      {
        \tl_put_right:Nn \l_@@_tmpa_tl {1}
      }
      {
        \tl_put_right:Nn \l_@@_tmpa_tl {0}
      }
    }
    {
      \int_compare:nNnTF {\seq_item:Nn \g_@@_output_seq {##1}} < {0}
      {
        \tl_put_right:Nn \l_@@_tmpa_tl {0}
      }
      {
        \tl_put_right:Nn \l_@@_tmpa_tl {1}
      }
    }
  }
  \int_zero:N \l_@@_tmpb_int
  \tl_map_inline:Nn \l_@@_tmpa_tl
  {
    \int_set:Nn \l_@@_tmpb_int {2 * \l_@@_tmpb_int}
    \int_compare:nNnT {##1} > {0}
    {
      \int_incr:N \l_@@_tmpb_int
    }
  }
  \begin{itemize}
  \item Oxygen~Rate:~\int_use:N \l_@@_tmpa_int
\item Carbon~Dioxide~Rate:~\int_use:N \l_@@_tmpb_int
\item Life~Support~Rating:~\int_eval:n {\l_@@_tmpa_int * \l_@@_tmpb_int}
  \end{itemize}
}
%    \end{macrocode}
% \end{macro}
%
% \iffalse
%</advent>
% \fi
%\Finale
\endinput
